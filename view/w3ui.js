// Generated by LiveScript 1.5.0
"use strict";
/***/
var w3ui, toString$ = {}.toString;
w3ui = function(){
  var DEP, CLONE, PROXY, BOUNCE, THREAD, CORE, API;
  DEP = [[Object.entries, "ECMAScript® 2018"], [window.requestAnimationFrame, "WHATWG HTML Living Standard"], [document.body.offsetLeft !== undefined, "CSSOM View Module 2016"]];
  DEP = function(){
    var b, i$, ref$, len$, a;
    b = true;
    for (i$ = 0, len$ = (ref$ = DEP).length; i$ < len$; ++i$) {
      a = ref$[i$];
      if (!a[0]) {
        b = false;
        console.log("w3ui require " + a[1]);
      }
    }
    return b;
  }();
  if (!DEP) {
    return null;
  }
  CLONE = function(obj, trace){
    var i$, len$, ref$, a, b, c, own$ = {}.hasOwnProperty;
    trace == null && (trace = []);
    switch (toString$.call(obj).slice(8, -1)) {
    case 'Date':
      return new Date(obj.getTime());
    case 'RegExp':
      return new RegExp(obj);
    case 'Object':
      if (Object.prototype !== Object.getPrototypeOf(obj)) {
        return obj;
      }
      for (i$ = 0, len$ = trace.length; i$ < len$; ++i$) {
        ref$ = trace[i$], a = ref$[0], b = ref$[1];
        if (obj === a) {
          return b;
        }
      }
      c = {};
      for (a in obj) if (own$.call(obj, a)) {
        b = obj[a];
        c[a] = CLONE(b, trace);
      }
      trace.push([obj, c]);
      obj = c;
      break;
    case 'Array':
      for (i$ = 0, len$ = trace.length; i$ < len$; ++i$) {
        ref$ = trace[i$], a = ref$[0], b = ref$[1];
        if (obj === a) {
          return b;
        }
      }
      c = obj.map(function(a){
        return CLONE(a, trace);
      });
      for (a in obj) if (own$.call(obj, a)) {
        b = obj[a];
        c[a] = CLONE(b, trace);
      }
      trace.push([obj, c]);
      obj = c;
      break;
    default:

    }
    return obj;
  };
  PROXY = function(){
    var get, set;
    get = function(hand){
      return function(obj, key, prx){
        if (typeof key !== 'string') {
          return false;
        }
        if (key[0] === '$') {
          return obj[key];
        }
        if (!hand.get) {
          return obj.$data ? obj.$data[key] : null;
        }
        return hand.get.call(obj.$scope, obj.$data, key, prx);
      };
    };
    set = function(hand){
      return function(obj, key, val, prx){
        if (typeof key !== 'string') {
          return true;
        }
        if (key[0] === '$') {
          obj[key] = val;
          return true;
        }
        if (!hand.set) {
          if (obj.$data) {
            obj.$data[key] = val;
          }
          return true;
        }
        return hand.set.call(obj.$scope, obj.$data, key, val, prx);
      };
    };
    return function(obj, handler){
      var a, b;
      a = handler.init ? handler.init(obj) : obj;
      a = {
        $scope: a,
        $data: a,
        $clone: function(obj){
          return PROXY(obj, handler);
        }
      };
      b = clone$(handler);
      b.get = get(handler);
      b.set = set(handler);
      return new Proxy(a, b);
    };
  }();
  BOUNCE = function(opts, func){
    if (!opts.scope) {
      opts.scope = null;
    }
    if (!opts.time) {
      opts.time = 20;
    }
    if (!opts.args) {
      opts.args = [];
    }
    if (typeof func !== "function") {
      return 0;
    }
    func = function(){
      func.apply(opts.scope, opts.args);
    };
    return window.setTimeout(func, opts.time);
  };
  THREAD = function(chain){
    var index, func;
    index = 0;
    func = function(){
      window.requestAnimationFrame(function(){
        switch (chain[index]()) {
        case false:
          func();
          break;
        case true:
        case undefined:
          if (chain[++index]) {
            func();
          }
        }
        return;
      });
    };
    func();
  };
  CORE = {
    id: 0,
    name: "ui",
    namespace: ".w3",
    element: null,
    api: {
      create: function(){
        var ui, module, opts, proto, i$, ref$, len$, a;
        ui = arguments[0]; module = arguments[1]; opts = arguments[2];
        if (ui[2].indexOf(this) >= 0) {
          if (typeof opts !== "object") {
            return true;
          }
          return module.api.setup(opts);
        }
        proto = clone$(module);
        proto.id = ui.uniqueId();
        proto.namespace += proto.id;
        proto.element = $(this);
        proto.api.setup(opts);
        for (i$ = 0, len$ = (ref$ = ["mouse", "sensor"]).length; i$ < len$; ++i$) {
          a = ref$[i$];
          if (proto[a]) {
            proto[a].namespace += proto.id;
            if (!proto[a].create()) {
              proto.log("initialization of " + a + " failed");
              return false;
            }
          }
        }
        if (!proto.create()) {
          proto.log("creation failed");
          return false;
        }
        ui[1].push((ref$ = {}, ref$[id] = proto, ref$));
        proto.element.addClass(proto.name);
        return true;
      },
      setup: function(option, val){
        var a, b, own$ = {}.hasOwnProperty;
        switch (typeof option) {
        case "object":
          for (a in option) if (own$.call(option, a)) {
            b = option[a];
            if (!a in this.options) {
              this.log("unsupported option «" + a + "»");
              return false;
            }
            if (toString$.call(this.options[a]).slice(8, -1) !== toString$.call(b).slice(8, -1)) {
              this.log("wrong option type «" + a + "»");
              return false;
            }
          }
          for (a in option) if (own$.call(option, a)) {
            b = option[a];
            if (a in CORE.options) {
              this.options[a] = b;
            }
          }
          for (a in option) if (own$.call(option, a)) {
            b = option[a];
            if (!a in CORE.options) {
              if (!this.setup(a, b)) {
                return false;
              }
            }
          }
          break;
        case "string":
          if (!option in this.options) {
            this.log("unsupported option «" + option + "»");
            return false;
          }
          if (val === undefined) {
            return this.options[option];
          }
          if (toString$.call(this.options[option]).slice(8, -1) !== toString$.call(val).slice(8, -1)) {
            this.log("wrong type for the option «" + option + "»");
            return false;
          }
          if (option in CORE.options) {
            this.options[option] = val;
          } else {
            if (!this.setup(option, val)) {
              return false;
            }
          }
          break;
        default:
          return this.options.clone(true);
        }
        return true;
      },
      refresh: function(){
        return true;
      },
      addEvents: function(){
        return true;
      },
      event: function(){
        return true;
      },
      delEvents: function(){
        return true;
      },
      destroy: function(){
        return true;
      }
    },
    options: PROXY({
      animate: true,
      disabled: false,
      log: true
    }, {
      set: function(list, option, val){
        var a;
        if (!option in list) {
          return true;
        }
        switch (option) {
        case "animate":
          val = val && !!window.TweenMax;
          break;
        case "disabled":
          a = this.element;
          a.toggleClass(option, !!val);
          a.removeClass('hover');
          a.removeClass('focus');
        }
        list[option] = val;
        return true;
      },
      get: function(list, option){
        if (!option in list) {
          return false;
        }
        switch (option) {
        case "animate":
          return list[option] ? window.TweenMax : false;
        }
        return list[option];
      }
    }),
    inject: function(module, name){
      var a, ref$, b, i$, len$, c, d, ref1$, e, own$ = {}.hasOwnProperty;
      this.name = CORE.name + "-" + name;
      this.namespace = CORE.namespace + this.name;
      if (!Object.keys(this.api).every(function(method){
        if (!module[method]) {
          this.log(method + "() unimplemented");
          return false;
        }
        if (typeof module[method] !== "function") {
          this.log(method + " is not a function");
          return false;
        }
        return true;
      })) {
        return false;
      }
      for (a in ref$ = this.api) if (own$.call(ref$, a)) {
        b = ref$[a];
        if (a !== "create") {
          this.api[a] = b.bind(this);
        }
      }
      this.options.scope = this;
      for (a in ref$ = module.options) if (own$.call(ref$, a)) {
        b = ref$[a];
        this.options[a] = b;
      }
      for (i$ = 0, len$ = (ref$ = ['mouse', 'sensor']).length; i$ < len$; ++i$) {
        a = ref$[i$];
        if (b = this[a] && (c = module[a])) {
          b.core = this;
          b.namespace = this.namespace + "-" + a;
          b.element = this.element;
          for (d in ref1$ = c.options) if (own$.call(ref1$, d)) {
            e = ref1$[d];
            b[d] = e;
          }
          for (d in ref1$ = c.api) if (own$.call(ref1$, d)) {
            e = ref1$[d];
            b[d] = e.bind(this);
          }
        }
      }
      for (a in module) if (own$.call(module, a)) {
        b = module[a];
        if (!a in this) {
          this[a] = b;
        }
      }
      return true;
    },
    mouse: {
      api: {
        down: function(e){
          return true;
        },
        drag: function(e){
          return true;
        },
        up: function(e){},
        click: function(e){},
        move: function(e){
          return true;
        }
      },
      options: {
        disabled: false,
        drag: true,
        cancel: ["input", "textarea", "button", "select", "option"],
        delay: 0,
        distance: 1,
        which: 0
      },
      data: {
        click: true,
        drag: false,
        event: null,
        delay: 0
      },
      create: function(){
        var me, a, b;
        me = this;
        a = this.element;
        b = this.namespace;
        a.on("mousedown" + b, function(event){
          return me.event("down", event);
        });
        a.on("click" + b, function(event){
          return me.event("click", event);
        });
        return true;
      },
      event: function(handler, event){
        var a;
        if (this.options.disabled || this.core.options.disabled) {
          event.stopPropagation();
          event.preventDefault();
          return false;
        }
        if (a = this[handler](event)) {
          event.stopImmediatePropagation();
          event.stopPropagation();
          event.preventDefault();
        }
        return a;
      },
      down: function(event){
        var me, d, o, a, b;
        me = this;
        d = this.data;
        o = this.options;
        if (!o.drag) {
          return this.api.down.apply(this.core, [event]);
        }
        if (o.which && event.which !== o.which) {
          return false;
        }
        if (d.drag) {
          d.click = false;
          this.up(event);
        }
        d.event = event;
        if (d.drag = this.api.down.apply(this.core, [event])) {
          a = this.document;
          b = this.namespace;
          a.on("mousemove" + b, function(event){
            return me.event("move", event);
          });
          a.on("mouseup" + b, function(event){
            return me.event("up", event);
          });
          o.delay && (d.delay = BOUNCE({
            time: o.delay
          }, function(){
            d.delay = 0;
          }));
        }
        return d.drag;
      },
      up: function(event){
        var d, o;
        d = this.data;
        o = this.options;
        if (!d.drag) {
          this.api.up.apply(this.core, [event]);
          return true;
        }
        d.drag = false;
        this.document.off(this.namespace);
        if (o.delay && d.delay) {
          window.clearTimeout(d.delay);
          d.delay = 0;
        }
        this.api.up.apply(this.core, [event]);
        return true;
      },
      move: function(event){
        var d, o, a, b;
        d = this.data;
        o = this.options;
        if (!o.drag || !d.drag) {
          return this.api.move.apply(this.core, [event]);
        }
        if (event.which !== d.event.which) {
          this.up(event);
          return true;
        }
        if (d.delay) {
          return true;
        }
        if (o.distance) {
          a = Math.abs(d.event.pageX - event.pageX);
          b = Math.abs(d.event.pageY - event.pageY);
          a = Math.max(a, b);
          if (a < o.distance) {
            return true;
          }
        }
        if (!this.api.drag.apply(this.core, [event])) {
          this.up(event);
        }
        return true;
      },
      click: function(event){
        var d;
        d = this.data;
        if (!d.click) {
          d.click = true;
          event.stopImmediatePropagation();
        } else {
          this.api.click.apply(this.core, [event]);
        }
        return true;
      },
      destroy: function(){
        this.element.off(this.namespace);
        this.document.off(this.namespace);
      }
    },
    sensor: {
      api: {
        offset: function(x, y){},
        resize: function(x, y){},
        scroll: function(x, y){}
      },
      options: {
        disabled: false
      },
      data: {
        'class': "ui-sensor",
        target: [],
        sensor: [],
        event: [],
        state: null
      },
      create: function(){
        var me, d, i$, ref$, len$, b, a;
        me = this;
        d = this.data;
        this.refresh();
        this.scan().forEach(function(node){
          return me.add(node);
        });
        for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
          b = i$;
          a = ref$[i$];
          a[0].addEventListener("scroll", d.event[b]);
          a[2].addEventListener("scroll", d.event[b]);
          this.recharge(b);
        }
        return true;
      },
      refresh: function(){
        var a;
        a = this.element[0];
        a = [[a.offsetLeft, a.offsetTop], [a.offsetWidth, a.offsetHeight], [a.scrollLeft, a.scrollTop]];
        a[0].map(function(val){
          if (val === null) {
            return 0;
          } else {
            return val;
          }
        });
        this.data.state = a;
      },
      scan: function(){
        var me, d, a, b, c, i$, ref$, len$, parent, j$, ref1$, len1$, index, node;
        me = this;
        d = this.data;
        a = this.element.parents().get();
        a.push(this.element);
        if (a.length === 1) {
          return a;
        }
        if ((b = a.indexOf(document.body)) > 0) {
          a = a.slice(0, b - 1);
        }
        b = {
          display: ['block', 'flex'],
          position: ['static', 'relative']
        };
        c = this.element;
        for (i$ = 0, len$ = (ref$ = a.slice()).length; i$ < len$; ++i$) {
          parent = ref$[i$];
          for (j$ = 0, len1$ = (ref1$ = parent.children).length; j$ < len1$; ++j$) {
            index = j$;
            node = ref1$[j$];
            if (node === c) {
              break;
            }
            d = $(node).css(b.keys()).entries();
            d = d.every(fn$);
            if (d) {
              a.push(node);
            }
          }
          c = parent;
        }
        return a;
        function fn$(node){
          return b[node[0]] && b[node[0]].includes(node[1]);
        }
      },
      add: function(node){
        var me, d, c, a, b;
        me = this;
        d = this.data;
        if (d.target.includes(node)) {
          return;
        }
        c = $(node);
        if ((a = c.children("." + d['class'])).length === 0) {
          a = document.createElement("div");
          a.className = d['class'];
          b = "position:absolute;left:0;top:0;";
          a.style.cssText = b + "right:0;bottom:0;" + "overflow:hidden;z-index:-1;visibility:hidden;opacity:0;";
          a.innerHTML = "<div style='" + a.style.cssText + "'><div style='" + b + "'></div></div>" + "<div style='" + b + "width:200%;height:200%;'></div>";
          c.append(a);
          b = 'position';
          if (c.css(b === 'static')) {
            c.css(b, 'relative');
          }
          a = $(a);
          b = a[0];
          a.add([b.children[1], b.children[0], b.children[0].children[0]]);
        }
        if (!(b = a.data(d['class']))) {
          b = 0;
        }
        a.data(d['class'], b + 1);
        b = d.sensor.length;
        d.target[b] = node;
        d.sensor[b] = a;
        d.event[b] = this.event.bind(this, b);
        true;
      },
      event: function(index, event){
        var d, s, a;
        d = this.data;
        s = d.state;
        event.stopPropagation();
        event.preventDefault();
        this.refresh();
        this.recharge(index);
        if (this.options.disabled) {
          return true;
        }
        a = s.map(function(lst, a){
          return lst.some(function(val, b){
            return Math.abs(val - s[a][b]) > 0.00001;
          });
        });
        if (a.every(function(val){
          return val === false;
        })) {
          return true;
        }
        if (a[0]) {
          this.api.offset.apply(this.core, a[0]);
        }
        if (a[1]) {
          this.api.resize.apply(this.core, a[1]);
        }
        if (a[2]) {
          this.api.scroll.apply(this.core, a[2]);
        }
        return true;
      },
      recharge: function(index){
        var a, b;
        if (!(a = this.data.sensor[index])) {
          return;
        }
        b = 10000;
        a[0].scrollLeft = b;
        a[0].scrollTop = b;
        a[2].scrollLeft = b;
        a[2].scrollTop = b;
        a[3].style.width = b + "px";
        a[3].style.height = b + "px";
      },
      destroy: function(){
        var d, i$, ref$, len$, b, a, c;
        d = this.data;
        for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
          b = i$;
          a = ref$[i$];
          a[0].removeEventListener("scroll", d.event[b]);
          a[2].removeEventListener("scroll", d.event[b]);
          c = a.data(d['class']);
          if (!c || c === 1) {
            a.remove();
          } else {
            a.data(d['class'], c - 1);
          }
        }
        d.target.length = 0;
        d.sensor.length = 0;
        d.event.length = 0;
      }
    }
  };
  DEP = {
    CLONE: CLONE,
    PROXY: PROXY,
    BOUNCE: BOUNCE,
    THREAD: THREAD,
    ready: function(f){
      document.addEventListener('DOMContentLoaded', f);
    }
  };
  API = function(){
    var api, hand;
    api = {
      style: {
        _get: function(key){
          var a, b;
          a = this._style[this._index];
          b = a[key];
          if (b === undefined) {
            b = key.replace(/([A-Z])/g, function(b){
              return '-' + b[0].toLowerCase();
            });
            b = a.getPropertyValue('--' + b);
          }
          if (b && b.includes('px')) {
            b = parseFloat(b);
            if (isNaN(b)) {
              b = 0;
            }
          }
          return b;
        },
        _set: function(key, val){
          var a, b;
          a = this._style[this._index];
          b = a[key];
          if (b === undefined) {
            b = key.replace(/([A-Z])/g, function(b){
              return '-' + b[0].toLowerCase();
            });
            this._node[this._index].style.setProperty('--' + b, val);
          } else {
            this._node[this._index].style[key] = val;
          }
          return true;
        }
      },
      box: {
        ctx: function(){
          return document.createElement('canvas').getContext('2d');
        }(),
        innerWidth: function(){
          var a, b;
          a = this._node.style[this._index];
          b = this._node[this._index];
          return b.clientWidth - (a.paddingLeft + a.paddingRight);
        },
        innerHeight: function(){
          var a, b;
          a = this._node.style[this._index];
          b = this._node[this._index];
          return b.clientHeight - (a.paddingTop + a.paddingBottom);
        },
        textMetrics: function(text, fontSize){
          var a;
          fontSize == null && (fontSize = 0);
          a = this._style[this._index];
          if (!fontSize) {
            fontSize = a.fontSize;
          } else {
            fontSize = fontSize + 'px';
          }
          a = [a.fontStyle, a.fontWeight, fontSize, a.fontFamily];
          this.ctx.font = a.join(' ');
          return this.ctx.measureText(text);
        },
        fontSize: function(text){
          var a, b, c, d;
          if (!text || !typeof text === 'string') {
            return 0;
          }
          a = this.innerHeight();
          b = this.innerWidth();
          c = [0, a];
          while (c[1] - c[0] > 0.5) {
            if (!(d = this.textMetrics(text, a))) {
              return 0;
            }
            if (d.width <= b) {
              c[0] = a;
            } else {
              c[1] = a;
            }
            a = c[0] + (c[1] - c[0]) / 2.0;
          }
          return c[0];
        }
      },
      'class': {
        add: function(a){
          this._node[this._index].classList.add(a);
        },
        remove: function(a){
          this._node[this._index].classList.remove(a);
        },
        toggle: function(a, b){
          return this._node[this._index].classList.toggle(a, b);
        },
        contains: function(a){
          return this._node[this._index].classList.contains(a);
        },
        replace: function(a, b){
          return this._node[this._index].classList.replace(a, b);
        }
      },
      attribute: {
        set: function(name, value){
          this._node[this._index].setAttribute(name, value);
        },
        get: function(name){
          return this._node[this._index].getAttribute(name);
        },
        del: function(name){
          this._node[this._index].removeAttribute(name);
        },
        exist: function(name){
          return this._node[this._index].hasAttribute(name);
        }
      },
      node: {
        clone: function(deep){
          deep == null && (deep = true);
          return this._node[this._index].cloneNode(deep);
        },
        append: function(node){
          this._node[this._index].appendChild(node);
        },
        prepend: function(node){
          var a, b;
          a = this._node[this._index];
          b = a.firstChild || null;
          a.insertBefore(node, b);
        },
        insert: function(node, index){
          var a, b;
          a = this._node[this._index];
          if (arguments.length < 2 || a.children.length === 0) {
            a.appendChild(node);
          } else {
            if (index < 0) {
              index = 0;
            } else if (index > (b = a.children.length - 1)) {
              index = b;
            }
            a.insertBefore(node, a.children[index]);
          }
        },
        remove: function(node){
          node == null && (node = this._node[this._index]);
          node.parentNode.removeChild(node);
        }
      },
      query: function(selector, index, noWrap){
        index == null && (index = 0);
        noWrap == null && (noWrap = false);
        if (typeof selector !== 'string' || index < 0 || index > this.length - 1) {
          return null;
        }
        selector = this._selector ? this._selector + ' ' + selector : selector;
        return API(selector, noWrap, this[index]);
      },
      eq: function(index){
        if (index < 0 || index > this.length - 1) {
          return null;
        }
        return API(this[index]);
      },
      prop: function(name, value){
        if (arguments.length > 1) {
          this.forEach(function(a){
            a.setAttribute(name, value);
          });
          return true;
        }
        return this[0].getAttribute(name);
      },
      propRemove: function(name){
        this.forEach(function(a){
          a.removeAttribute(name);
        });
      },
      html: function(a){
        this.forEach(function(node){
          node.innerHTML = a;
        });
      },
      addClass: function(a){
        this.forEach(function(b){
          b.classList.add(a);
        });
      },
      removeClass: function(a){
        this.forEach(function(c){
          c.classList.remove(a);
        });
      },
      toggleClass: function(a, b){
        this.forEach(function(c){
          c.classList.toggle(a, b);
        });
      },
      hasClass: function(a){
        return this.some(function(b){
          return b.classList.contains(a);
        });
      }
    };
    hand = {
      get: function(obj, key, prx){
        var index;
        index = parseInt(key);
        if (isNaN(index)) {
          if (obj._get) {
            return obj._get(key);
          }
          if (!obj[key]) {
            return null;
          }
          if (obj[key].length) {
            return obj[key].bind(obj);
          }
          return obj[key].call(obj);
        }
        if (index < 0 || index > obj._node.length - 1) {
          return null;
        }
        if (index === obj._index) {
          return prx;
        }
        obj = clone$(obj);
        obj._index = index;
        return new Proxy(obj, hand);
      },
      set: function(obj, key, val, prx){
        if (key[0] === '_') {
          obj[key] = val;
          return true;
        }
        if (obj._set) {
          obj._set(key, val);
        }
        return true;
      }
    };
    return function(selector, noWrap, parent){
      var node, a, i$, to$, b, style, ref$, own$ = {}.hasOwnProperty;
      noWrap == null && (noWrap = false);
      parent == null && (parent = document);
      if (!selector) {
        return null;
      }
      node = [];
      if (typeof selector === 'string') {
        a = parent.querySelectorAll(selector);
        if (!a || !a.length) {
          return null;
        }
        for (i$ = 0, to$ = a.length - 1; i$ <= to$; ++i$) {
          b = i$;
          node[b] = a[b];
        }
      } else {
        if (!(selector instanceof HTMLElement)) {
          return null;
        }
        node = [selector];
        selector = '';
      }
      if (noWrap) {
        return node;
      }
      style = node.map(function(node){
        return window.getComputedStyle(node);
      });
      node._selector = selector;
      node._parent = parent;
      for (a in ref$ = api) if (own$.call(ref$, a)) {
        b = ref$[a];
        if (typeof b === 'object') {
          b = clone$(b);
          b._node = node;
          b._style = style;
          b._index = 0;
          b = new Proxy(b, hand);
        }
        node[a] = b;
      }
      return node;
    };
  }();
  API[0] = {};
  API[1] = [];
  API[2] = [];
  return new Proxy(API, {
    /***
    set: (ui, name, module) -> # load module {{{
        # prepare
        # inject helpers {{{
        if not ui.log
            # template log function
            ui.log = (name, msg) !->
                if CORE.options.log
                    if not msg
                        msg  = name
                        name = CORE.name
                    console.log "w3"+name+": "+msg
            # simple id generator
            ui.uniqueId = ->
                ui.id = if ui.id
                    then 1 + ui.id
                    else 0
                ui.id
        # }}}
        # check rings
        if 0 <= Object.keys ui.0 .indexOf name
            ui.log name+" is already loaded"
            return true
        # create core prototype
        proto = ^^CORE
        proto.id  = ui.uniqueId!
        proto.log = ui.log.bind proto, name
        # inject module
        if not proto.inject module, name
            return false
        # store
        ui.0[name] = proto
        # define entry point
        module = ->
            CORE.api.create.apply this, [ui, proto] ++ arguments.0
        # extend jQuery with module api
        # and return it
        jQuery.fn.extend {
            (proto.name): PROXY module, {
                get: (f, method, prx) -> # {{{
                    # get method
                    return proto.api[method] if proto.api[method]
                    # check aliases
                    for a,b of proto.api.alias when (b.indexOf method) >= 0
                        return proto.api[a]
                    # method not found
                    ui.log method+"() unimplemented"
                # }}}
                set: (f, method, params, prx) -> # {{{
                    # get method
                    method = prx.get f, method, prx
                    # call method with single parameter
                    # dont care about the result
                    method params
                    true
                # }}}
            }
        }
    # }}}
    /***/
    get: function(ui, method){
      if (DEP[method]) {
        return DEP[method];
      }
      return true;
    }
  });
}();
w3ui && (w3ui.slider = {
  /* {{{
  * TODO:
  * task #10: slider constructor
  * negative values
  * large values
  * multiple handles >2
  * multiple ranges, minmax, array
  * <-(arrow capture keys)-> with acceleration
  * custom animation (external api)
  * better sync for handle/range animation
  * new standard with slash(/) syntax in border-radius
  * revise relative option
  * optimize range refresh routine
  * image slider
  */
  options: {
    minmax: [0, 100],
    count: 1,
    step: 1,
    margin: [],
    value: [0],
    range: [0, 0],
    orientation: true,
    strict: false,
    inner: false,
    round: 0,
    toggle: false,
    k_pages: 5,
    k_range: ["ctrlKey", "HOME", "END"],
    k_value: ["ctrlKey", "LEFT", "RIGHT"]
  },
  data: {
    handles: null,
    handleIndex: -1,
    min: 0,
    max: 100,
    shift: 0,
    size: 100,
    margin: 0,
    val: null,
    scale: null
  },
  create: function(){
    var d, o, a, b, i$, c, e, to$;
    d = this.data;
    o = this.options;
    a = this.element.query("*");
    b = o.count;
    if (a.length > b) {
      a.slice(b).remove();
      a = a.slice(0, b);
    } else if (a.length < b) {
      for (i$ = a.length; i$ <= b; ++i$) {
        c = i$;
        e = document.createElement("div");
        this.element.append(e);
        a.push(e);
      }
    }
    a.addClass(this.name + "-handle");
    for (i$ = 0, to$ = a.length; i$ <= to$; ++i$) {
      c = i$;
      a[c].setAttribute("tabindex", "0");
      a.eq(c).addClass("n" + (c + 1));
    }
    a.size = this.getHandleSize();
    a.pos = d.handleSize.map(function(){
      return {
        left: 0,
        top: 0
      };
    });
    d.handles = a;
    if (d.range) {
      if (!d.range$) {
        b = [];
        for (i$ = 0, to$ = d.range.length; i$ <= to$; ++i$) {
          a = i$;
          if (d.range[a] >= 0) {
            a = document.createElement('div');
            b.push(a);
            this.element.append(a);
          }
        }
        b = $(b);
        b.addClass(this.name + "-range");
        b.each(function(index){
          return b.eq(index).addClass('n' + (index + 1));
        });
        d.range$ = $(b);
      }
      d.range$.css({
        left: "",
        top: ""
      });
      a = ['min', 'max'];
      b = d.range.length - 1;
      o.direction && a.reverse();
      d.range[0] < 0 && d.range.element.eq(0).addClass(a[0]);
      d.range[b] < 0 && d.range.element.eq(b).addClass(a[1]);
    } else if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    return this.refresh(true);
  },
  setup: function(option, val){
    var d, o, a, i$, ref$, to$, b, c, v, len$, m;
    d = this.data;
    o = this.options;
    switch (option) {
    case "minmax":
      if (val.length === 0) {
        this.log("option minmax is empty");
        return false;
      }
      if (val.length > 2) {
        this.log("minmax should containt two integers");
        val = val.slice(0, 2);
      }
      val = val.map(function(val){
        return Math.round(val);
      });
      if (val[0] === val[1]) {
        this.log("min and max are equal, that is wrong");
        val[1] += 100;
      }
      a = val.slice();
      d.reversed = a[0] < a[1];
      if (d.reversed) {
        a.reverse();
      }
      d.shift = a[0] < 0 ? -a[0] : 0;
      if (d.shift) {
        a[0] = 0;
        a[1] = a[1] + d.shift;
      }
      d.min = a[0];
      d.max = a[1];
      d.size = a[1] - a[0];
      break;
    case "count":
      val = Math.round(val);
      if (val <= 0) {
        this.log("slider must have at least one value");
        val = 1;
      }
      if (val > (a = this.valMaxCount())) {
        this.log("handle count limit is " + a);
        val = a;
      }
      if (val > o.count) {
        for (i$ = o.count; i$ <= val; ++i$) {
          a = i$;
          o.margin.push(0);
          o.value.push((ref$ = o.value)[ref$.length - 1]);
          o.range.push(0);
        }
      } else if (val < o.count) {
        for (i$ = val, to$ = o.count; i$ <= to$; ++i$) {
          a = i$;
          o.margin.pop();
          o.value.pop();
          o.range.pop();
        }
      }
      break;
    case "step":
      val = Math.round(val);
      if (val <= 0) {
        this.log("step should be positive, >0");
        val = 1;
      }
      a = Math.round((d.max - d.min) / o.count);
      if (val > a) {
        this.log("step is too big, maximum is " + a);
        val = a;
      }
      break;
    case "margin":
      val = val.map(function(val){
        var a;
        val = Math.round(val);
        if (val < 0) {
          this.log("margin (" + val + ") should be positive");
          val = 0;
        }
        if ((a = val % o.step) !== 0) {
          this.log("margin (" + val + ") should be aligned with step (" + o.step + ")");
          val -= a;
        }
        return val;
      });
      a = val.reduce(function(a, b){
        return a + b;
      }, 0);
      b = d.max - d.min - a;
      c = Math.round(a / o.step);
      if (b <= 0 || c < o.count) {
        this.log("the total margin (" + a + ") is too big");
        return true;
      }
      d.margin = a;
      break;
    case "value":
      if (val.length < o.count) {
        this.log("wrong values count, at least " + o.count + " must be set");
        return true;
      }
      if (val.length > o.count) {
        this.log("no more than " + o.count + " values allowed");
        val = val.slice(0, o.count);
      }
      v = val.map(function(v){
        return Math.round(v);
      }).sort(function(a, b){
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      });
      d.shift && (v = v.map(function(v){
        return v + d.shift;
      }));
      for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
        b = i$;
        a = v[i$];
        if (a < d.min) {
          v[b] = d.min;
        }
        if (a > d.max) {
          v[b] = d.max;
        }
      }
      if (d.margin) {
        m = o.margin;
        for (i$ = 0, len$ = m.length; i$ < len$; ++i$) {
          b = i$;
          a = m[i$];
          if (a > 0) {
            if ((c = v[b + 1] - v[b]) >= a) {
              continue;
            }
            c = a - c;
            a = v[b] - c;
            if ((b === 0 && a >= d.min) || v[b - 1] + m[b - 1] >= a) {
              v[b] = a;
              continue;
            }
            a = v[++b] + c;
            if ((b >= m.length && a <= d.max) || v[b + 1] - a >= m[b]) {
              v[b] = a;
              continue;
            }
            this.log("failed to apply margins to this value set");
            return true;
          }
        }
      }
      d.val = v;
      break;
    case "range":
      val = val.map(function(val){
        return !!val;
      });
      a = o.count + 1;
      while (val.length < a) {
        val.push(false);
      }
      if (val.length > a) {
        val.slice(0, a);
      }
      break;
    case "toggle":
      val = !!val;
      if (o.count === 1 && val) {
        this.log("toggle is supported only for single handle");
        val = false;
      }
      break;
    case "orientation":
      a = ["horizontal", "vertical"];
      this.element.toggleClass(this.name + "-" + a[0], val);
      this.element.toggleClass(this.name + "-" + a[1], !val);
      break;
    default:
      this.log("option " + option + " is not filtered");
    }
    this.options[option] = val;
    return true;
  },
  refresh: function(init){
    var d, o, a, b, c;
    d = this.data;
    o = this.options;
    a = this.element[0];
    a = {
      left: a.offsetLeft,
      top: a.offsetTop,
      height: a.offsetHeight,
      width: a.offsetWidth,
      h: a.clientHeight,
      w: a.clientWidth,
      margin: 0,
      handle: 0
    };
    this.element.parents().each(function(index, el){
      a.left += el.scrollLeft;
      a.top += el.scrollTop;
    });
    b = o.orientation
      ? [a.w(a.h)]
      : [a.h(a.w)];
    if (d.margin) {
      c = d.margin / d.size;
      a.margin = b[0] * c;
    }
    a.handle = o.inner
      ? b[1]
      : 1.5 * b[1];
    c = o.round ? this.cssValue(b[1] / 2) : "";
    this.element.css("border-radius", c);
    d.scale = a;
    a = [];
    d.handles.each(function(index, node){
      var b;
      b = {
        w: node.clientWidth,
        h: node.clientHeight,
        width: node.offsetWidth,
        height: node.offsetHeight,
        w_gap: 0,
        h_gap: 0
      };
    });
    /***
    # определим классификаторы фиксированной оси и шкалы
    a = ["h", "height", "innerHeight", "outerHeight", "h_gap"];
    b = ["w", "width",  "innerWidth",  "outerWidth",  "w_gap"];
    @orientation && (d = a, a = b, b = d);
        # ..
        # prepare
        #node = d.handles.eq index
        # добавляем индекс
        #node.data "ui-slider-handle-index", index
        # определяем зазор
        d[a[4]] = el[a[3]](true) - d[a[0]];
        d[b[4]] = el[b[3]](true) - d[b[0]];
        # определяем полный размер ползунка
        # фиксированная ось
        c = @elementSize.handle;# авто-размер
        # в случае, если текущий стиль не конфликтует с опциями,
        # оставляем его, иначе назначаем авто-размер.
        d[a[1]] = (d[a[0]] > 1 && (!@options.inner || d[a[0]] < c)) ?
                (d[a[0]] + d[a[4]]) : c;
        # шкала
        d[b[1]] = (d[b[0]] > 1) ?
                (d[b[0]] + d[b[4]]) : c;
        # определяем внутренний размер
        d[a[0]] = Math.abs(d[a[1]] - d[a[4]]);
        d[b[0]] = Math.abs(d[b[1]] - d[b[4]]);
        # кривизна границ
        c = @options.round;
        if (c > 1)
        {
            # закругленные границы
            # в зависимости от внутреннего размера ползунка на фиксированной оси
            d["border-radius"] = @_cssValue(d[a[0]] / 2);
            # круглый ползунок
            if (c > 2)
            {
                # размеры симметричны (длина == ширина)
                # за основу берем размер на фиксированной оси
                d[b[0]] = d[a[0]];
                d[b[1]] = d[b[0]] + d[b[4]];
                d["border-radius"] = "50%";
            }
        }
        # определим соотношение внутренних размеров
        d.scale = d[b[0]] / d[a[0]]; # плавающая / фиксированная
        # сохраняем
        e[index] = d;
        true
    
    # определяем размер
    
    
    
    e = [];
    
    
    @handles.toArray!forEach(function(el, index) {
    }, this);
    
    
    
    
    # align on fixed axis
    d.handles.each (index, node) !->
        # determine offset (center)
        d = @handleSize[index];
        e = @elementSize[b[0]];
        e = [
            d[b[0]],
            e / 2.0 - d[b[1]] / 2.0,
            e,
            "border-radius"
        ]
        # проверка необходимости
        if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
            Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
        {
            # выполняем позиционирование
            # без анимации
            a = {};
            a[b[1]] = @_cssValue(e[0], e[2]);
            a[b[2]] = @_cssValue(e[1], e[2]);
            if (d[e[3]]) {
                a[e[3]] = d[e[3]];
            }
            node.css(a);
        }
    # ..
    
    
    
    
    
    
    
    
    
    
    
    # ..
    a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
    b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"]
    @orientation && (c = a, a = b, b = c);
    # collect handles
    for (c = [], d = 0; d < @val.length; d++) {
        c[d] = @handles.eq(d);
    }
    # 1. позиционируем на шкале
    # {{{
    # вычисляем полный размер
    d = @handleSize;
    d.full = 0;
    c.forEach(function(node, index) {
        # подготовка
        e = d[index];
        # размер на шкале пропорционален размеру на фиксированной оси
        # внутренний размер
        e[a[0]] = e.scale * e[b[0]];
        # полный размер
        e[a[1]] = e[a[0]] + e[a[5]];
        d.full += e[a[1]];
    });
    # позиционирование
    c.forEach(function(node, index) {
        # обновляем размер
        # без анимации
        d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
        e = {}, e[a[1]] = d;
        node.css(e);
        # обновляем смещение
        # с условной анимацией
        @_refreshHandle(index, !fixedAxis);
    }, this);
    # }}}
    /***/
    this.refreshRange();
    return true;
  },
  addEvents: function(){},
  event: function(){
    return true;
  },
  delEvents: function(){
    this._mouseDestroy();
    this._off(this.handles);
    return $(window).off("resize." + this.eventNamespace);
  },
  destroy: function(){
    var d;
    this.delEvents();
    d = this.data;
    d.handle.remove();
    delete d.handle;
    delete d.handleSize;
    delete d.handleOffset;
    if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    return true;
  },
  api: {
    alias: {
      value: ['val', 'value', 'values'],
      range: ['range', 'ranges']
    }
    /***
    value: function(val, index) { # {{{
        var a, b;
        ##
        a = arguments.length;
        if (!a) {
            return @values(0);
        }
        b = typeof val;
        if (b !== "number" && b !== "string") {
            return false;
        }
        if (a === 1) {
            return @values(0, val);
        }
        if (index < 0 || index >= @val.length) {
            return false;
        }
        return @values(index, val);
    },
    # }}}
    values: function(index, val) { # {{{
        var a, b, c;
        ##
        # подготовка
        a = arguments.length;
        b = arguments[0];
        # возвращаем все значения
        if (a === 0) {
            return @_valueRefined(@val, true);
        }
        # сохраняем массив значений
        if (a === 1 && jQuery.isArray(b))
        {
            if (!@_event("change", null, -1, @_valueRefined(b))) {
                return b;
            }
            return @_valueRefined(b, true);
        }
        # сохраняем единственное значение
        if (a === 2)
        {
            b = @_valueRefined(val);
            c = @val.slice!
            c[index] = b;
            return @_event("change", null, index, c) ? b : false;
        }
        # возвращаем единственное значение
        return @_valueRefined(@val[index]);
    },
    # }}}
    range: function(index) { # {{{
        index = arguments.length ? 0 + index : 0;
        return @ranges(index);
    },
    # }}}
    ranges: function() { # {{{
        var a, b, c, d;
        ##
        if (!@_rangeMap) {
            return false;
        }
        # подготовка
        a = arguments.length;
        b = [];
        for (c = 0; c < @_rangeMap.length; c += 2)
        {
            d = [
                @_rangeMap[c],
                @_rangeMap[c + 1]
            ];
            @options.direction && d.reverse!
            d[0] = d[0] < 0 ? @min : @val[d[0]];
            d[1] = d[1] < 0 ? @max : @val[d[1]];
            b.push(Math.abs(d[1] - d[0]));
        }
        # возврат
        if (a === 0) {
            return b;
        }
        a = index < 0 || index >= b.length ? 0 : index;
        return b[a];
    },
    # }}}
    /***/
  },
  mouse: {
    down: function(e){
      return true;
    },
    drag: function(e){
      return true;
    },
    up: function(e){},
    click: function(e){},
    move: function(e){
      return true;
    }
    /***
    _mouseEventCoords: function(e) { # {{{
        var a, b, c;
        ##
        # определим относительную позицию указателя
        # вычисляем scroll
        a = {x: e.pageX, y: e.pageY};
        b = @element.parents!
        for (c = 0; c < b.length; c++)
        {
            a.x = a.x + b.eq(c).scrollLeft!
            a.y = a.y + b.eq(c).scrollTop!
        }
        return a;
    },
    # }}}
    _mouseValue: function(coords, capture) { # {{{
        var a, b, c, d, e;
        ##
        # определяем значение шкалы в месте клика
        # в зависимости от ориентации слайдера
        a = @orientation ?
            [coords.y - @elementOffset.top,  "height", "top"] :
            [coords.x - @elementOffset.left, "width", "left"];
        # определяем ближайший ползунок
        d = @_getClosestHandle(coords);
        # определяем длину шкалы
        b = @_getScaleSize(d, true);
        # определяем смещение (относительная позиция)
        c = (a[0] - b[0]) / b[1];
        # инвертируем в случае вертикального слайдера
        @orientation && (c = 1 - c);
        # проверка выхода за границы
        c > 1 && (c = 1);
        c < 0 && (c = 0);
        # вычисляем абсолютное значение
        a = [
            @_valueMin(d),
            @_valueMax(d)
        ];
        b = a[0] + c * (a[1] - a[0]);
        # определяем текущее значение
        c = @options.toggle ?
            @val[d] : @_valueTrim(b, d);
        # определяем шаг
        e = @step ? (@max - @min) / @step : 1;
        # корректировка
        if (Math.abs(@val[d] - c) < 0.0001 &&
            Math.abs(b - c) >= 1 && # минимальный инкремент
            (capture || @options.toggle))
        {
            # значение не может остатся неизменным в случае,
            # когда указатель выбирает точку на шкале
            c = c > b ? c - e : c + e;
        }
        # проверяем выход за границы
        c > a[1] && (c = a[1]);
        c < a[0] && (c = a[0]);
        # возврат
        return c;
    },
    # }}}
    _mouseCapture: function(e) { # {{{
        var a, b;
        ##
        # проверка
        if (@options.disabled) {
            return false;
        }
        # определяем координаты
        a = @_mouseEventCoords(e);
        b = @_mouseValue(a, true);
        # инициируем событие
        return @_event("start", e, @_getClosestHandle(a), b);
    },
    # }}}
    _mouseDrag: function(e) { # {{{
        ##
        if (@options.toggle) {
            return false;
        }
        @_event("slide", e, @_handleIndex, @_mouseValue(@_mouseEventCoords(e)));
        return true;
    },
    # }}}
    _mouseStop: function(event) { # {{{
        @_event("stop", event);
    },
    # }}}
    /***/
  },
  valMaxCount: function(){
    return 10;
  },
  cssValue: function(val, scale){
    var a;
    if (scale) {
      a = (100.0 * val / scale).toFixed(5) + "%";
    } else {
      a = Math.round(val) + "px";
    }
    return a;
  }
  /** {{{ **
          # POSITIONING
      refreshScale: !-> # {{{
          # prepare
          d = @data
          o = @options
          # determine element size and position
          a = @element.0
          a =
              left:   a.offsetLeft
              top:    a.offsetTop
              height: a.offsetHeight
              width:  a.offsetWidth
              h:      a.clientHeight
              w:      a.clientWidth
              margin: 0
              handle: 0
          # apply scroll offset
          @element.parents!each (index, el) !->
              a.left += el.scrollLeft
              a.top  += el.scrollTop
          # determine scale and fixed axis size
          b = if o.orientation
              then [a.w a.h]
              else [a.h a.w]
          # determine margin size
          if d.margin
              # determine relative value
              c = d.margin / d.size
              # determine absolute value
              a.margin = b.0 * c
          # determine default handle size
          a.handle = if o.inner
              then b.1
              else 1.5 * b.1
          # determine border curvature
          c = if o.round
              then @cssValue b.1 / 2
              else ""
          # apply it
          @element.css "border-radius", c
          # save results
          d.scale = a
      # }}}
      refreshHandles: (fixedAxis) !-> # {{{
          # prepare
          d = @data
          o = @options
          # ..
          a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
          b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"];
          @orientation && (c = a, a = b, b = c);
          # определяем массив ползунков
          for (c = [], d = 0; d < @val.length; d++) {
              c[d] = @handles.eq(d);
          }
          # 1. позиционируем на шкале
          # {{{
          # вычисляем полный размер
          d = @handleSize;
          d.full = 0;
          c.forEach(function(node, index) {
              # подготовка
              e = d[index];
              # размер на шкале пропорционален размеру на фиксированной оси
              # внутренний размер
              e[a[0]] = e.scale * e[b[0]];
              # полный размер
              e[a[1]] = e[a[0]] + e[a[5]];
              d.full += e[a[1]];
          });
          # позиционирование
          c.forEach(function(node, index) {
              # обновляем размер
              # без анимации
              d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
              e = {}, e[a[1]] = d;
              node.css(e);
              # обновляем смещение
              # с условной анимацией
              @_refreshHandle(index, !fixedAxis);
          }, this);
          # }}}
          # 2. позиционируем на фиксированной оси
          # {{{
          if (fixedAxis) {
              c.forEach(function(node, index) {
                  # подготовка
                  # определяем смещение (центровка)
                  d = @handleSize[index];
                  e = @elementSize[b[0]];
                  e = [
                      d[b[0]],
                      e / 2.0 - d[b[1]] / 2.0,
                      e,
                      "border-radius"
                  ]
                  # проверка необходимости
                  if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
                      Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
                  {
                      # выполняем позиционирование
                      # без анимации
                      a = {};
                      a[b[1]] = @_cssValue(e[0], e[2]);
                      a[b[2]] = @_cssValue(e[1], e[2]);
                      if (d[e[3]]) {
                          a[e[3]] = d[e[3]];
                      }
                      node.css(a);
                  }
              }, this);
          }
          # }}}
          # complete
      # }}}
          refreshHandle: function(index, animate) { # {{{
              var a, b, c, d, e;
              ##
              # подготовка
              # в зависимости от ориентации слайдера
              a = @orientation ?
                  ["h", "height", "top"] :
                  ["w", "width", "left"];
              # определяем ползунок
              b = @handles.eq(index);
              # определяем виртуальное смещение
              c = @_getHandleOffset(index);
              @handleOffset[index][a[2]] = c;
              # определяем флаг анимации
              d = (animate && @options.animate) ?
                  @options.animate : 0;
              # определяем время анимации
              if (d)
              {
                  # определяем текущую позицию
                  e = b.position!
                  # определяем дистанцию
                  if ((e = Math.abs(c - e[a[2]])) < 0.0001) {
                      # позиционирование не требуется
                      return true;
                  }
                  # вычисляем относительное время анимации 1..0
                  e = e / (@elementSize[a[0]] - @handleSize.full);
                  # вычислем абсолютное время
                  # отсекаем минимальные значения
                  e = d * e / 2;
                  d = e <= 50 ? 0 : (e < d ? d : e);
              }
              # определяем параметр
              e = {};
              e[a[2]] = @_cssValue(c, @elementSize[a[0]]);
              # позиционируем
              if (d)
              {
                  # с анимацией
                  # останавливаем текущую
                  b.stop(@eventNamespace, true, @_capture);
                  # запуск
                  a = this;
                  b.animate(e, {
                      duration: d,
                      queue: @eventNamespace,
                      step: function(now, fx) {
                          # на каждом шаге анимации
                          # обновляем диапозон с текущим значением ползунка
                          a._refreshRange(a.handleOffset.map(function(val, idx) {
                              return idx === index ? b.position() : val;
                          }));
                      },
                      complete: function() {
                          # после завершения
                          a._refreshRange!
                      }
                  }).dequeue(@eventNamespace);
              }
              else
              {
                  # без анимации
                  # останавливаем текущую анимацию
                  if (@options.animate) {
                      b.stop(@eventNamespace, true, false);
                  }
                  # обновляем
                  b.css(e);
                  @_refreshRange!
              }
              return true;
          },
          # }}}
          refreshRange: function(queryPosition) { # {{{
              var a, b, c, d, e;
              ##
              # проверка
              if (!@_rangeMap) {
                  return true;
              }
              # подготовка
              a = ["left", "width",  "w", "w_gap",    "h_gap", "h", "height","top"];
              @orientation && a.reverse!
              ##
              # 1. на шкале
              # определяем начальную/конечную точки
              b = @_rangeMap.slice!
              # инвертируем при необходимости
              c = [
                  @orientation,
                  @options.direction,
                  @options.range === true
              ];
              if ((c[0] && (!c[1] || c[2])) ||    # вертикаль
                  (!c[0] && (c[1] && !c[2])))     # горизонталь
              {
                  b.reverse!
              }
              # диапазон
              # определяем позиции точек
              c = 0;
              d = 0;
              b = b.map(function(val, idx) {
                  ##
                  if (val < 0)
                  {
                      # граница
                      # определим параметры связанного ползунка
                      val = idx ? b[idx - 1] : b[idx + 1];
                      val = @handleSize[val];
                      d = val[a[3]];
                      c = val[a[1]] - d;
                      d = d / 2;
                      # определим позицию
                      e = idx ? @elementSize[a[2]] : 0;
                      # добавляем зазор ползунка,
                      # в случае, если его внутренний размер меньше
                      # размера слайдера на фиксированной оси
                      if (val[a[5]] <= @elementSize[a[5]]) {
                          e += (idx ? -1 : 1) * d;
                      }
                      else
                      {
                          # ползунок больше слайдера,
                          # отступ не нужен
                          d = 0;
                      }
                  }
                  else
                  {
                      # ползунок
                      # определим позицию
                      e = queryPosition ?
                          @handles.eq(val).position() : @handleOffset[val];
                      e = e[a[0]];
                      # корректируем
                      # небольшой отступ в зависимости от позиции ползунка
                      val = @handleSize[val];
                      e += (idx & 1) ?
                          (val[a[1]] - val[a[3]] / 2) : val[a[3]] / 2;
                  }
                  return e;
              }, this);
              # определяем размер
              b[1] = Math.abs(b[1] - b[0]);
              e = @elementSize[a[2]];
              if (c && b[1] < c - 2 * d)
              {
                  # если диапазон меньше чем один из ползунков,
                  # убираем его.. (граничные случаи)
                  b[1] = 0;
              }
              else if (b[1] > e - 2 * d)
              {
                  # диапазон не должен выходить за пределы шкалы
                  b[0] = d;
                  b[1] = e - 2 * d;
              }
              b[2] = d;
              d = {};
              d[a[0]] = @_cssValue(b[0], e);
              d[a[1]] = @_cssValue(b[1], e);
              ##
              # 2. на фиксированной оси
              # определяем наименьший внутренний размер
              a.reverse!
              e = @elementSize[a[2]];
              c = @_rangeMap.map(function(val, index) {
                  # шкала || ползунок
                  return (val < 0) ? e : @handleSize[val][a[2]];
              }, this);
              c[1] = Math.min(c[0], c[1], e);
              # определяем смещение (центровка)
              c[0] = c[1] < e ?  (e / 2 - c[1] / 2) : 0;
              # сохраняем
              d[a[0]] = @_cssValue(c[0], e);
              d[a[1]] = @_cssValue(c[1], e);
              ##
              # кривизна границ
              c[2] = "";
              if (@options.round) {
                  if (@options.round > 1)
                  {
                      # полное скругление
                      c[2] = @_cssValue(c[1] / 2);
                  }
                  else if (b[2] < e)
                  {
                      # скругление в случае когда прямоугольный ползунок
                      # входит в зону скругления шкалы
                      # вычислим радиус
                      e = e / 2;
                      e = (e - b[2]) / e;# относительное значение
                      e = (c[1] / 2) * e;# абсолютное
                      c[2] = @_cssValue(e);
                      # дополнительный радиус,
                      # когда радиус на шкале становится меньше радиуса
                      # на фиксированной оси (NEW syntax, future support?)
                      if (b[1] / 2 < e) {
                          c[2] = c[2] + " / " + @_cssValue(b[1] / 2);
                      }
                  }
              }
              d["border-radius"] = c[2];
              # позиционируем
              @_range.css(d);
              return true;
          },
          # }}}
          # UTILITY
          _getHandleOffset: function(index) { # {{{
              var a, b, c, d;
              ##
              # подготовка
              if (index === 0)
              {
                  a = @min;
                  b = @max;
              }
              else
              {
                  a = @_valueMin(index);
                  b = @_valueMax(index);
              }
              # определяем значение
              c = @val[index];
              # +margin
              # корректируем
              if ((d = @options.margin) && !(index & 1))
              {
                  c = c + d;
                  a = a + d;
              }
              # определяем относительное значение
              c = a === b ? 1 : (c - a) / (b - a);
              # определим размер виртуальной шкалы
              b = @_getScaleSize(index);
              # определим позицию на виртуальной шкале
              # инвертируем значение в случае вертикального слайдера
              c = c * b[1];
              @orientation && (c = b[1] - c);
              # центрируем ползунок относительно позиции
              a = @handleSize[index];
              c = c - (@orientation ? a.height : a.width) / 2;
              # возврат
              return c + b[0];
          },
          # }}}
          _getScaleSize: function(index, virtual) { # scale size and offset {{{
              var a, b, c, d, e;
              ##
              # виртуальная шкала привязана к конкретному ползунку
              # в зависимости от ориентации слайдера
              a = @orientation ?
                  ["height", "top", "h"] :
                  ["width", "left", "w"];
              # определим размер шкалы
              e = @elementSize[a[2]];
              if (index > 0 || virtual)
              {
                  # виртуальная шкала (шкала отдельного ползунка)
                  # #1
                  # предыдущий элемент, начальное смещение
                  c = index - 1;
                  if (c < 0)
                  {
                      b = @orientation ? e : 0;
                  }
                  else
                  {
                      # соседний ползунок
                      b = @handleOffset[c][a[1]];
                      # корректируем
                      if (!@orientation) {
                          if (@options.strict) {
                              b = b + @handleSize[c][a[0]];
                          }
                          else {
                              b = b + @handleSize[c][a[0]] / 2;
                          }
                      }
                      else if (!@options.strict) {
                          b = b + @handleSize[c][a[0]] / 2;
                      }
                  }
                  # #2
                  # определим конечное смещение
                  c = index + 1;
                  if (c >= @val.length) {
                      d = @orientation ? 0 : e;
                  }
                  else
                  {
                      # соседний ползунок
                      d = @handleOffset[c][a[1]];
                      # корректируем
                      if (@orientation)
                      {
                          if (@options.strict) {
                              d = d + @handleSize[c][a[0]];
                          }
                          else {
                              d = d + @handleSize[c][a[0]] / 2;
                          }
                      }
                      else if (!@options.strict) {
                          d = d + @handleSize[c][a[0]] / 2;
                      }
                  }
                  # инвертируем значения для вертикального слайдера
                  if (@orientation) {
                      a[3] = d, d = b, b = a[3];
                  }
              }
              else
              {
                  # вся шкала
                  # только для первого элемента
                  b = 0;
                  d = e;
                  if (@options.strict)
                  {
                      # определяем размер остальных ползунков
                      # не учитываем их на шкале
                      for (c = 1; c < @val.length; c++) {
                          b += @handleSize[c][a[0]];
                      }
                      !@orientation && (d = d - b, b = 0);
                  }
              }
              if (@options.strict)
              {
                  # точный слайдер сдвигает ползунки внутрь шкалы
                  a = @handleSize[index][a[0]] / 2.0;
                  b = b + a;
                  d = d - a;
              }
              # возврат [начало, размер шкалы, конец]
              return [b, d - b, d];
          },
          # }}}
          _getClosestHandle: function(coords) { # {{{
              var a, b, c, d;
              ##
              # определяем ближайший ползунок
              # при слайдинге, выбираем перетаскиваемый
              if (@_capture) {
                  return @_handleIndex;
              }
              # возвращаем индекс единственного ползунка
              if (@val.length < 2) {
                  return 0;
              }
              # подготовка
              # в зависимости от ориентации слайдера
              a = @orientation ?
                  [coords.y - @elementOffset.top,  "height", "top", @elementSize.h, 0] :
                  [coords.x - @elementOffset.left, "width", "left", @elementSize.w, 0];
              # для каждого ползунка
              for (b = 0; b < @val.length; b++)
              {
                  # определяем его центр
                  c = @handleOffset[b][a[2]] + @handleSize[b][a[1]] / 2.0;
                  # определяем расстояние до центра
                  if ((d = Math.abs(c - a[0])) < a[3])
                  {
                      # найден ближайший ползунок
                      a[3] = d;
                      a[4] = b;
                  }
                  else if (Math.abs(d - a[3]) < 0.0001)
                  {
                      # ползунки находятся в одной позиции,
                      # определяем положение относительно этой позиции
                      if (!@orientation && a[0] - c >= 0)
                      {
                          # выбираем ползунок справа
                          a[3] = d;
                          a[4] = b;
                      }
                      else if (@orientation && a[0] - c < 0)
                      {
                          # выбираем ползунок сверху
                          a[3] = d;
                          a[4] = b;
                      }
                  }
              }
              return a[4];
          },
          # }}}
          _valueMin: function(index) { # {{{
              if (@val.length < 2 || !index) {
                  return @min;
              }
              return @val[index - 1] + @options.margin;
          },
          # }}}
          _valueMax: function(index) { # {{{
              if (@val.length < 2 ||
                  index === undefined ||
                  index + 1 >= @val.length)
              {
                  return @max;
              }
              return @val[index + 1] - @options.margin;
          },
          # }}}
      valRefine: (val, outside) -> # {{{
          # prepare
          d = @data
          o = @options
          # single value
          if typeof! val != "Array"
              # apply reversed
              val = d.max - val + d.min if d.reversed
              # apply shift
              val = val + d.shift if d.shift and outside
              # trim
              return @valTrim val
          # multiple values
          # sync length
          while val.length < d.val.length
              val.push @valRefine d.max, outside
          # fix
          if outside
              # value is from outside world
              # apply shift and reversed
              val = val + d.shift if d.shift and outside
              d.reversed and val = val.map (val) ->
                  d.max - val + d.min;
          else
              # на вход
              val = val.map(function(val, index) {
                  # только целые числа в ограниченном диапазоне
                  val = @_valueTrim(val, index, true, true);
                  # инвертируем значение
                  return a ? (@max - val + @min) : val;
              }, this).sort(function(e1, e2) {
                  # сортировка по возрастанию
                  return e1 < e2 ? -1 : 1;
              });
              (a = @options.margin) && (val = val.map(function(val, index, arr) {
                  # корректируем значение в соответствии с отступом
                  # определяем диапазон
                  b = jQuery.inArray(index, @_rangeMap);
                  # отступ привязан к начальному ползунку диапазонa
                  if (b >= 0 && !(b & 1) && (c = @_rangeMap[b + 1]) > 0 &&
                      arr[c] - a < val) # отступ нарушен
                  {
                      # корректировка
                      # отталкиваемся от верхней границы
                      val = arr[c] - a;
                      if (val <= @min)
                      {
                          # на дне, поднимаем верхнюю границу
                          val = @min;
                          d = val + a;
                          arr[c] = d > @max ? @max : d;
                      }
                  }
                  return val;
              }, this));
          }
          return val;
          # ..
          true
      # }}}
      valTrim: (val, index, noMargin, forceStep) -> # {{{
          # returns the closest +step+margin-aligned value
          ##
          # подготовка
          forceStep = (forceStep && index !== undefined);
          # определим минимум и максимум
          a = [@min, @max, @min, @max];
          b = @val.length;
          c = 0;
          if (arguments.length > 1 && (b = @val.length) > 1)
          {
              # для нескольких ползунков,
              # границами являются соседние, но если задан флаг форсирования шага,
              # значение должно быть выравнено - упользуются границы min/max.
              if (!forceStep)
              {
                  if (index > 0) {
                      a[0] = @val[index - 1];
                  }
                  if (index < b - 1) {
                      a[1] = @val[index + 1];
                  }
              }
              # учитываем +margin
              if ((c = @options.margin) && (d = jQuery.inArray(index, @_rangeMap)) >= 0)
              {
                  # в зависимости от четности/нечетности,
                  # добавляем ограничение
                  if (d & 1) {
                      a[2] = a[0] + c;
                  }
                  else {
                      a[3] = a[1] - c;
                  }
              }
          }
          # проверка выхода за границы
          if (val < a[2]) {
              return a[2];
          }
          if (val > a[3]) {
              return a[3];
          }
          # корректируем значение
          if (@step)
          {
              # определим размер шага
              d = (@max - @min) / @step;
              d <= 1 && (d = 1);
              # приближаемся к значению
              for (b = @min; b + d <= val; b += d);
              b = [b, b + d];
              # определим ближайшее
              d = [Math.abs(val - b[0]), Math.abs(val - b[1])];
              if (d[0] !== d[1])
              {
                  # найдено
                  val = d[0] < d[1] ? b[0] : b[1];
              }
              else
              {
                  # оба приближения равноудалены,
                  # выбираем ближаешее к границе
                  d = [b[0] - a[0], a[1] - b[1]];
                  if (d[0] !== d[1])
                  {
                      # найдено
                      val = d[0] < d[1] ? b[0] : b[1];
                  }
                  else if (forceStep)
                  {
                      # по центру,
                      # определим ближайшее к текущему
                      return @val[index] <= b[0] ? b[0] : b[1];
                  }
                  else
                  {
                      # по центру,
                      # возвращаем как есть
                      return val;
                  }
              }
              # проверим выход за границы
              if (noMargin)
              {
                  val > a[1] && (val = a[1]);
                  val < a[0] && (val = a[0]);
              }
              else
              {
                  val > a[3] && (val = a[3]);
                  val < a[2] && (val = a[2]);
              }
          }
          return Math.round(val);
      },
      # }}}
  /** }}} **/
  /**** }}} */
});
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}