// Generated by LiveScript 1.5.0
"use strict";
/* web 3.0 user interface */
var w3ui, toString$ = {}.toString;
w3ui = function(){
  var DEP, CLONE, PROXY, THREAD, GSAP, WIDGET, API, APP;
  DEP = [[Object.entries, "ECMAScript® 2018"], [window.requestAnimationFrame, "WHATWG HTML Living Standard"], [document.body.offsetLeft !== undefined, "CSSOM View Module 2016"]];
  DEP = function(){
    var b, i$, ref$, len$, a;
    b = true;
    for (i$ = 0, len$ = (ref$ = DEP).length; i$ < len$; ++i$) {
      a = ref$[i$];
      if (!a[0]) {
        b = false;
        console.log("w3ui require " + a[1]);
      }
    }
    return b;
  }();
  if (!DEP) {
    return null;
  }
  CLONE = function(obj, trace){
    var i$, len$, ref$, a, b, c, own$ = {}.hasOwnProperty;
    trace == null && (trace = []);
    switch (toString$.call(obj).slice(8, -1)) {
    case 'Date':
      return new Date(obj.getTime());
    case 'RegExp':
      return new RegExp(obj);
    case 'Object':
      if (Object.prototype !== Object.getPrototypeOf(obj)) {
        return obj;
      }
      for (i$ = 0, len$ = trace.length; i$ < len$; ++i$) {
        ref$ = trace[i$], a = ref$[0], b = ref$[1];
        if (obj === a) {
          return b;
        }
      }
      c = {};
      for (a in obj) if (own$.call(obj, a)) {
        b = obj[a];
        c[a] = CLONE(b, trace);
      }
      trace.push([obj, c]);
      obj = c;
      break;
    case 'Array':
      for (i$ = 0, len$ = trace.length; i$ < len$; ++i$) {
        ref$ = trace[i$], a = ref$[0], b = ref$[1];
        if (obj === a) {
          return b;
        }
      }
      c = obj.map(function(a){
        return CLONE(a, trace);
      });
      for (a in obj) if (own$.call(obj, a)) {
        b = obj[a];
        c[a] = CLONE(b, trace);
      }
      trace.push([obj, c]);
      obj = c;
      break;
    default:

    }
    return obj;
  };
  PROXY = function(){
    var get, set;
    get = function(hand){
      return function(obj, key, prx){
        if (typeof key !== 'string') {
          return false;
        }
        if (key[0] === '$') {
          return obj[key];
        }
        if (!hand.get) {
          return obj.$data ? obj.$data[key] : null;
        }
        return hand.get.call(obj.$scope, obj.$data, key, prx);
      };
    };
    set = function(hand){
      return function(obj, key, val, prx){
        if (typeof key !== 'string') {
          return true;
        }
        if (key[0] === '$') {
          obj[key] = val;
          return true;
        }
        if (!hand.set) {
          if (obj.$data) {
            obj.$data[key] = val;
          }
          return true;
        }
        return hand.set.call(obj.$scope, obj.$data, key, val, prx);
      };
    };
    return function(obj, handler, scope){
      var a, b;
      scope == null && (scope = obj);
      a = handler.init ? handler.init(obj) : obj;
      a = {
        $scope: scope,
        $data: a,
        $clone: function(obj){
          return PROXY(obj, handler);
        }
      };
      b = clone$(handler);
      b.get = get(handler);
      b.set = set(handler);
      return new Proxy(a, b);
    };
  }();
  THREAD = function(chain){
    var index, func;
    index = 0;
    func = function(){
      window.requestAnimationFrame(function(){
        switch (chain[index]()) {
        case false:
          func();
          break;
        case true:
        case undefined:
          if (chain[++index]) {
            func();
          }
        }
        return;
      });
    };
    func();
  };
  GSAP = {
    queue: function(node, queue){
      var t;
      t = new TimelineLite({
        paused: true
      });
      if (queue) {
        this.add(t, node, queue, true);
      }
      return t;
    },
    add: function(timeline, node, source, noPosition){
      var this$ = this;
      if (!node || ('length' in node && !node.length)) {
        return;
      }
      if ('w3ui' in node) {
        node = node.nodes;
      }
      source && source.forEach(function(a){
        var pos, b;
        switch (typeof a) {
        case 'object':
          if (a.node) {
            node = a.node;
          }
          pos = a.position && !noPosition ? a.position : '+=0';
          if (!node || ('length' in node && !node.length)) {
            break;
          }
          if (a.label) {
            timeline.addLabel(a.label, pos);
            break;
          }
          if (a.func) {
            timeline.add(a.func, pos);
            break;
          }
          if (a.group) {
            b = new TimelineLite({
              paused: true
            });
            this$.add(b, node, a.group);
            if (a.duration) {
              b.duration(a.duration);
            }
            timeline.add(b.play(), pos);
            break;
          }
          if (!a.to && !a.from) {
            break;
          }
          b = [a.to ? w3ui.CLONE(a.to) : null, a.from ? w3ui.CLONE(a.from) : null];
          if (!a.duration || a.duration < 0.0001) {
            timeline.set(node, b[0] || b[1], pos);
            break;
          }
          if (b[0] && !b[1]) {
            timeline.to(node, a.duration, b[0], pos);
            break;
          }
          if (!b[0] && b[1]) {
            timeline.from(node, a.duration, b[1], pos);
            break;
          }
          timeline.fromTo(node, a.duration, b[0], b[1], pos);
          break;
        case 'function':
          if (a.length) {
            b = new Proxy(timeline, apiHandler);
            timeline.addPause('+=0', a, [b]);
          } else {
            timeline.add(a);
          }
          break;
        case 'string':
          timeline.addLabel(a);
        }
      });
    },
    pauseAll: function(timeline){
      do {
        timeline.pause();
      } while (timeline = timeline.timeline);
    },
    resumeAll: function(timeline){
      do {
        if (!timeline.isActive()) {
          timeline.resume();
        }
      } while (timeline = timeline.timeline);
    },
    removeAtLabel: function(timeline, label){
      var a, b, i$, len$, c;
      if ((a = timeline.getLabelTime(label)) === -1) {
        return;
      }
      b = timeline.getChildren(false, true, true, a);
      for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
        c = b[i$];
        if (c.startTime() === a) {
          console.log('found a tween to remove at [' + label + ']');
          timeline.remove(c);
        }
      }
    }
  };
  WIDGET = {
    store: {},
    proxy: {
      set: function(api, name, widget){
        if (!api.store) {
          api.store = WIDGET.store;
        }
        if (name in api.store) {
          console.log('w3ui: widget «' + name + '» already exist, check your code');
          return true;
        }
        api.store[name] = widget;
        return true;
      },
      get: function(api, name){
        if (name in DEP) {
          return DEP[name];
        }
        if (!('store' in api)) {
          console.log('w3ui: widget storage is empty');
          return null;
        }
        return function(selector, opts){
          var widget, node, w, options;
          if (!(name in api.store)) {
            console.log('w3ui: widget «' + name + '» is not loaded');
            return null;
          }
          widget = api.store[name];
          if (!(node = api(selector)) || node.length !== 1) {
            console.log('w3ui: DOM query failed for «' + selector + '»');
            return null;
          }
          w = import$(clone$(WIDGET.proto), widget);
          w.name = name;
          w.node = node;
          w.data = 'data' in widget
            ? CLONE(widget.data)
            : {};
          options = import$(clone$(WIDGET.optionsProto), widget.options);
          options = PROXY(options, WIDGET.optionsProxy, w);
          Object.defineProperty(w, 'options', {
            set: function(val){
              var a, b, i$, len$, c;
              if (typeof val !== 'object') {
                return;
              }
              a = Object.keys(val);
              b = in$('_order', options)
                ? options._order.slice()
                : [];
              for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
                c = a[i$];
                if (!b.includes(c)) {
                  b.push(c);
                }
              }
              for (i$ = 0, len$ = b.length; i$ < len$; ++i$) {
                a = b[i$];
                options[a] = val[a];
              }
            },
            get: function(){
              return options;
            }
          });
          if (w.init && !w.init()) {
            console.log('w3ui.' + name + ': init failed');
            return null;
          }
          if (w.options.setClass) {
            node[0]['class'].add(['w3ui', name]);
          }
          w.options = opts;
          if (!w.create()) {
            console.log('w3ui.' + name + ': failed to create on «' + selector + '»');
            return null;
          }
          return w;
        };
      }
    },
    proto: {
      log: function(msg){
        if (this.options.log) {
          console.log('w3ui.' + this.name + ': ' + msg);
        }
      }
    },
    optionsProto: {
      setClass: true,
      animate: true,
      disabled: false,
      log: true
    },
    optionsProxy: {
      set: function(opts, key, val){
        if (!(key in opts)) {
          this.log('unknown option «' + key + '»');
          return true;
        }
        if ('setOption' in this) {
          val = this.setOption(key, val);
        }
        if (val !== undefined) {
          opts[key] = val;
        }
        return true;
      },
      get: function(opts, key){
        if (!(key in opts)) {
          return null;
        }
        if (key[0] === '_') {
          return opts[key];
        }
        if ('getOption' in this && !this.getOption(key)) {
          return null;
        }
        return CLONE(opts[key]);
      }
    },
    context2d: function(){
      return document.createElement('canvas').getContext('2d');
    }()
  };
  API = function(){
    var api, apiProxy, apiBind, wrapNode, getNodes;
    api = {
      w3ui: {
        _property: true,
        get: function(){
          return this;
        }
      },
      query: {
        _func: function(selector, noWrap){
          noWrap == null && (noWrap = false);
          if (this.selector) {
            selector = this.selector + ' ' + selector;
          }
          return API(selector, this.node, noWrap);
        }
      },
      node: {
        _property: true,
        get: function(){
          return this.node;
        }
      },
      nodes: {
        _property: true,
        get: function(){
          return this.nodes;
        }
      },
      clone: {
        _func: function(deep){
          deep == null && (deep = true);
          return this.node.cloneNode(deep);
        }
      },
      html: {
        _property: true,
        get: function(){
          return this.node.innerHTML;
        },
        set: function(val){
          this.node.innerHTML = val;
        }
      },
      style: {
        _proxy: true,
        get: function(data, key){
          var a;
          a = data.style[key];
          if (a === undefined) {
            a = key.replace(/([A-Z])/g, function(a){
              return '-' + a[0].toLowerCase();
            });
            a = data.style.getPropertyValue('--' + a);
          }
          if (a && a.includes('px')) {
            a = parseFloat(a);
            if (isNaN(a)) {
              a = 0;
            }
          }
          return a;
        },
        set: function(data, key, val){
          var a;
          if (data.style[key] === undefined) {
            a = key.replace(/([A-Z])/g, function(a){
              return '-' + a[0].toLowerCase();
            });
            data.node.style.setProperty('--' + a, val);
          } else {
            data.node.style[key] = val;
          }
          return true;
        }
      },
      box: {
        innerWidth: function(){
          var a, b;
          a = this.api.style;
          b = this.node;
          return b.clientWidth - (a.paddingLeft + a.paddingRight);
        },
        innerHeight: function(){
          var a, b;
          a = this.api.style;
          b = this.node;
          return b.clientHeight - (a.paddingTop + a.paddingBottom);
        },
        textMetrics: function(text, fontSize){
          var a, b, c;
          fontSize == null && (fontSize = 0);
          a = this.api.style;
          b = WIDGET.context2d;
          c = fontSize
            ? fontSize
            : a.fontSize;
          c = [a.fontStyle, a.fontWeight, c + 'px', a.fontFamily];
          b.font = c.join(' ');
          return b.measureText(text);
        },
        fontSize: function(text){
          var api, a, b, c, d;
          if (!text || !typeof text === 'string') {
            return 0;
          }
          api = this.api.box;
          a = api.innerHeight;
          b = api.innerWidth;
          c = [0, a];
          while (c[1] - c[0] > 0.5) {
            if (!(d = api.textMetrics(text, a))) {
              return 0;
            }
            if (d.width <= b) {
              c[0] = a;
            } else {
              c[1] = a;
            }
            a = c[0] + (c[1] - c[0]) / 2.0;
          }
          return c[0];
        }
      },
      'class': {
        _property: true,
        _proxy: true,
        set: function(val){
          if (typeof val === 'string') {
            this.node.className = val;
          }
        },
        has: function(name){
          return this.node.classList.contains(name);
        },
        add: function(name){
          var this$ = this;
          if (typeof name === 'string') {
            this.node.classList.add(name);
            return;
          }
          name.forEach && name.forEach(function(a){
            this$.node.classList.add(a);
          });
        },
        remove: function(name){
          var this$ = this;
          if (!name) {
            this.api['class'].clear();
            return;
          }
          if (typeof name === 'string') {
            this.node.classList.remove(name);
            return;
          }
          name.forEach && name.forEach(function(name){
            this$.node.classList.remove(name);
          });
        },
        clear: function(except){
          var a, b, c;
          except == null && (except = '');
          a = this.node.classList;
          b = a.length;
          if (!except) {
            while (--b >= 0) {
              a.remove(a.item(b));
            }
          } else {
            except += ' ';
            while (--b >= 0) {
              c = a.item(b);
              if (!except.includes(c + ' ')) {
                a.remove(c);
              }
            }
          }
        },
        replace: function(name0, name1){
          return this.node.classList.replace(name0, name1);
        },
        toggle: function(name, flag){
          if (typeof flag === 'function') {
            flag = flag(this.wrap, this.index);
          }
          return this.node.classList.toggle(name, !!flag);
        }
      },
      prop: {
        _proxy: true,
        get: function(data, key){
          key = key.replace(/([A-Z])/g, function(a){
            return '-' + a[0].toLowerCase();
          });
          return data.node.getAttribute(key);
        },
        set: function(data, key, val){
          key = key.replace(/([A-Z])/g, function(a){
            return '-' + a[0].toLowerCase();
          });
          if (val === null) {
            data.node.removeAttribute(key);
            return true;
          }
          data.node.setAttribute(key, val);
          return true;
        },
        has: function(data, key){
          return data.node.hasAttribute(name);
        }
      },
      child: {
        add: function(node, parent){
          parent == null && (parent = this.node);
          if ('w3ui' in node) {
            node = node.w3ui.group
              ? node.nodes
              : node.node;
            api.child.add(node, parent);
            return;
          }
          if (toString$.call(node).slice(8, -1) === 'Array') {
            node.forEach(function(node){
              parent.appendChild(node);
            });
          } else {
            parent.appendChild(node);
          }
        },
        insert: function(node, index, parent){
          var a;
          index == null && (index = 0);
          parent == null && (parent = this.node);
          if (parent.children.length === 0) {
            api.child.add(node, parent);
            return;
          }
          if (index < 0) {
            index = 0;
          } else if (index > (a = parent.children.length - 1)) {
            index = a;
          }
          a = parent.children[index];
          if ('w3ui' in node) {
            node = node.w3ui.group
              ? node.nodes
              : node.node;
            api.child.insert(node, index, parent);
            return;
          }
          if (toString$.call(node).slice(8, -1) === 'Array') {
            node.forEach(function(node){
              parent.insertBefore(node, a);
            });
          } else {
            parent.insertBefore(node, a);
          }
        },
        remove: function(node, parent){
          var a;
          node == null && (node = null);
          parent == null && (parent = this.node);
          if (!node) {
            a = document.createRange();
            a.selectNodeContents(parent);
            a.deleteContents();
            return;
          }
          if ('w3ui' in node) {
            node = node.w3ui.group
              ? node.nodes
              : node.node;
            api.child.remove(node, parent);
            return;
          }
          if (toString$.call(node).slice(8, -1) === 'Array') {
            return node.forEach(function(node){
              parent.removeChild(node);
            });
          } else {
            return parent.removeChild(node);
          }
        }
      },
      addEventListener: {
        _property: true,
        get: function(){
          return this.node.addEventListener.bind(this.node);
        }
      },
      removeEventListener: {
        _property: true,
        get: function(){
          return this.node.removeEventListener.bind(this.node);
        }
      }
    };
    apiProxy = {
      get: function(arg$, key){
        var data, api;
        data = arg$[0], api = arg$[1];
        if (!isNaN(parseInt(key)) || !(api = api[key])) {
          return null;
        }
        return api.length > 0
          ? api.bind(data)
          : api.call(data);
      },
      set: function(arg$, key, val){
        var data, api;
        data = arg$[0], api = arg$[1];
        if ('set' in api) {
          api.set.call(data, key, val);
        }
        return true;
      }
    };
    apiBind = function(data, target){
      var b, ref$, a, c;
      target == null && (target = {});
      for (b in ref$ = api) {
        a = ref$[b];
        if (a._func) {
          a = {
            value: a._func.bind(data)
          };
        } else if (a._property) {
          c = {};
          if (a._proxy) {
            c.get = (fn$.call(this, new Proxy([data, a], apiProxy)));
          } else if ('get' in a) {
            c.get = a.get.bind(data);
          }
          if (a.set) {
            c.set = a.set.bind(data);
          }
          a = c;
        } else if (a._proxy) {
          a = {
            value: new Proxy(data, a)
          };
        } else {
          a = {
            value: new Proxy([data, a], apiProxy)
          };
        }
        Object.defineProperty(target, b, a);
      }
      return target;
      function fn$(a){
        return function(){
          return a;
        };
      }
    };
    wrapNode = function(node, boundApi){
      return new Proxy(node, {
        get: function(node, key){
          return key in api
            ? boundApi[key]
            : Reflect.get(node, key);
        },
        set: function(node, key, val){
          if (key in api) {
            boundApi[key] = val;
            return true;
          }
          return Reflect.set(node, key, val);
        },
        has: function(node, key){
          return key in api
            ? true
            : Reflect.has(node, key);
        }
      });
    };
    getNodes = function(selector, parent){
      var node, a, i$, to$, b, len$;
      parent.w3ui && (parent = parent.w3ui.node);
      node = [];
      if (typeof selector === 'string') {
        a = selector
          ? parent.querySelectorAll(selector)
          : parent.children;
        if (!a || !a.length) {
          return null;
        }
        for (i$ = 0, to$ = a.length - 1; i$ <= to$; ++i$) {
          b = i$;
          node[b] = a[b];
        }
      } else {
        if (!selector) {
          return null;
        }
        if ('w3ui' in selector) {
          selector = selector.nodes;
        }
        if (!Array.isArray(selector)) {
          selector = [selector];
        }
        for (i$ = 0, len$ = selector.length; i$ < len$; ++i$) {
          a = selector[i$];
          if (!(a instanceof HTMLElement)) {
            return null;
          }
        }
        node = selector;
        selector = '';
      }
      return node;
    };
    return function(selector, parent, noWrap){
      var node, style, data, wrap;
      parent == null && (parent = document);
      noWrap == null && (noWrap = false);
      if (!(node = getNodes(selector, parent))) {
        return null;
      }
      if (noWrap) {
        return node;
      }
      style = node.map(function(node){
        return window.getComputedStyle(node);
      });
      data = {
        group: true,
        selector: selector,
        nodes: node,
        node: node[0],
        index: 0,
        parent: parent,
        style: style
      };
      wrap = node.map(function(node, index){
        var a;
        a = Object.create(data);
        a.group = false;
        a.node = node;
        a.index = index;
        a.style = style[index];
        a.api = apiBind(a);
        a.wrap = wrapNode(node, a.api);
        return a.wrap;
      });
      return apiBind(wrap[0].w3ui, wrap);
    };
  }();
  APP = function(){
    var MODEL, VIEW, PRESENTER;
    MODEL = {
      data: {
        nav: [
          {
            id: ''
          }, {
            id: ''
          }, {
            id: ''
          }, {
            id: ''
          }, {
            id: ''
          }
        ],
        navHistory: [{}, {}, {}, {}],
        navDefault: null,
        navPath: function(){
          return this.nav.map(function(a){
            return a.id;
          });
        }
      },
      proxy: {
        init: function(obj){
          var a;
          a = obj.nav;
          obj.navHistory.forEach(function(save, level){
            save[''] = w3ui.CLONE(a.slice(level + 1));
          });
          obj.navDefault && obj.navDefault.forEach(function(id, level){
            obj.nav[level].id = id;
          });
          return obj;
        },
        set: function(obj, k, v, prx){
          var a, nav, sav, i$, to$, b, len$, c;
          a = parseInt(k);
          if (isNaN(a)) {
            obj[k] = v;
            return true;
          }
          k = a;
          nav = obj.nav;
          a = nav[k];
          sav = k < obj.navHistory.length ? obj.navHistory[k] : null;
          if (a.id === v && v === '') {
            return true;
          }
          if (a.id === v) {
            v = '';
          }
          if (sav) {
            k++;
            sav[a.id] = w3ui.CLONE(nav.slice(k));
            for (i$ = k, to$ = nav.length - 1; i$ <= to$; ++i$) {
              b = i$;
              w3ui.clearObject(nav[b]);
            }
            sav = sav[v]
              ? sav[v]
              : sav[''];
            for (i$ = 0, len$ = sav.length; i$ < len$; ++i$) {
              c = i$;
              b = sav[i$];
              import$(nav[k + c], sav[c]);
            }
          }
          a.id = v;
          return true;
        },
        get: function(obj, p, prx){
          var k;
          k = parseInt(p);
          if (!isNaN(k)) {
            return obj.nav[k].id;
          }
          if (!(p in obj)) {
            return null;
          }
          k = obj[p];
          if (typeof k === 'function' && k.length === 0) {
            return k();
          }
          return obj[p];
        }
      }
    };
    VIEW = {
      init: function(){
        var M, V, P, initNode, initAnimation;
        M = null;
        V = null;
        P = null;
        initNode = function(id, node, parent, level, tid){
          var cfg, a, b, own$ = {}.hasOwnProperty;
          cfg = node.cfg;
          if (level > 0) {
            tid = tid + '-' + id;
          }
          cfg.id = id;
          cfg.parent = parent;
          cfg.level = level;
          cfg.nav = M.nav[level];
          if (cfg.render !== undefined) {
            cfg.render = V.render.bind(node, cfg.render);
          }
          if (cfg.attach) {
            cfg.attach = V.attach.bind(node, P, cfg.attach);
          }
          cfg.template = V.template.querySelector(tid);
          cfg.data = {};
          cfg.el = V.el;
          cfg.show && initAnimation(node, cfg.show);
          cfg.hide && initAnimation(node, cfg.hide);
          if (cfg.turn) {
            if (cfg.turn.on) {
              initAnimation(node, cfg.turn.off);
              initAnimation(node, cfg.turn.on);
            } else {
              initAnimation(node, cfg.turn);
            }
          }
          for (a in node) if (own$.call(node, a)) {
            b = node[a];
            if (a !== 'cfg' && b && b.cfg) {
              this.init(a, b, node, level + 1, tid);
            }
          }
          return true;
        };
        initAnimation = function(node, queue){
          var i$, len$, b, a;
          for (i$ = 0, len$ = queue.length; i$ < len$; ++i$) {
            b = i$;
            a = queue[i$];
            if (typeof a === 'function') {
              queue[b] = a.bind(node);
              continue;
            }
            if (a.func) {
              queue[b].func = a.func.bind(node);
              continue;
            }
            if (a.group) {
              initAnimation(node, a.group);
            }
          }
        };
        return function(){
          M = arguments[0]; V = arguments[1]; P = arguments[2];
          V.template = document.querySelector('template').content;
          V.init = initNode.bind(V);
          V.el = V.el(M, V);
          V.call = V.call(M);
          if (!V.init('ui', V.ui, null, 0, '#t')) {
            console.log('w3ui.app: failed to initialize view');
            return false;
          }
          return true;
        };
      }(),
      render: function(template, old){
        var id, a, b, c, d;
        old == null && (old = '');
        id = this.cfg.nav.id;
        if (!this.cfg.node) {
          this.cfg.node = w3ui('#' + this.cfg.id);
        }
        a = this.cfg.parent;
        b = !a || a.cfg.nav.id === this.cfg.id ? id : '';
        if (!b && id && (c = a[a.cfg.nav.id][id])) {
          this.cfg.context = c;
        }
        if (!template || !id) {
          return true;
        }
        if (!this.cfg.node) {
          return false;
        }
        if (b) {
          a = this[id].cfg.template.innerHTML;
          c = this[id];
        } else {
          a = (a = this.cfg.template.querySelector('#' + id)) ? a.innerHTML : '';
          c = this[id] ? this[id].render.call(this) : null;
        }
        if (!(a = Mustache.render(a, c))) {
          return true;
        }
        d = document.createElement('template');
        d.innerHTML = a.trim();
        c = b
          ? w3ui('#' + b, d.content)
          : w3ui('', d.content);
        c.style.display = 'none';
        if (old) {
          this.cfg.node.child.insert(c);
        } else {
          this.cfg.node.child.remove();
          this.cfg.node.child.add(c);
        }
        if (b) {
          this[id].cfg.node = c;
        } else {
          this[id].node = c;
        }
        return true;
      },
      attach: function(P, event){
        var a, b, c, i$, len$, ref$;
        if (event === true) {
          if (!(a = this.cfg.nav.id) || !(b = this[a])) {
            return true;
          }
          event = b.attach;
        }
        if (toString$.call(event).slice(8, -1) !== 'Array' || !event.length) {
          return true;
        }
        c = [];
        for (i$ = 0, len$ = event.length; i$ < len$; ++i$) {
          a = event[i$];
          b = !a.el
            ? [this.cfg.node]
            : typeof a.el === 'string'
              ? API(a.el, this.cfg.node, true)
              : a.el.length
                ? a.el
                : [a.el];
          if (!('preventDefault' in a)) {
            a.preventDefault = !/^key.+/.test(a.event);
          }
          if (!('handler' in a)) {
            a.handler = P.event.bind(this, a);
          }
          c.push([a, b]);
        }
        this.cfg.detach = function(){
          var i$, ref$, len$, ref1$, a, b;
          for (i$ = 0, len$ = (ref$ = c).length; i$ < len$; ++i$) {
            ref1$ = ref$[i$], a = ref1$[0], b = ref1$[1];
            b.forEach(fn$);
          }
          delete this.detach;
          return true;
          function fn$(b){
            b.removeEventListener(a.event, a.handler);
          }
        };
        this.cfg.detach.data = {};
        for (i$ = 0, len$ = c.length; i$ < len$; ++i$) {
          ref$ = c[i$], a = ref$[0], b = ref$[1];
          b.forEach(fn$);
        }
        return true;
        function fn$(b){
          b.addEventListener(a.event, a.handler);
        }
      },
      el: function(M, V){
        return PROXY(V.ui, {
          get: function(obj, id, prx){
            var root, a, b, k, v, own$ = {}.hasOwnProperty;
            if (obj.cfg.id === id) {
              return obj;
            }
            if (!(root = M[0])) {
              return null;
            }
            if (!(obj = obj[root])) {
              return null;
            }
            if (!id || obj.cfg.id === id) {
              return obj;
            }
            if (obj[id] && obj[id].cfg) {
              return obj[id];
            }
            a = [obj];
            while (a.length) {
              b = a.pop();
              for (k in b) if (own$.call(b, k)) {
                v = b[k];
                if (k !== 'cfg' && v && v.cfg) {
                  if (v[id] && v[id].cfg) {
                    return v[id];
                  }
                  a.push(v);
                }
              }
            }
            return null;
          }
        });
      },
      list: function(id){
        var x, a, b;
        x = [];
        if (!(a = this.el[id])) {
          return x;
        }
        b = [a];
        while (b.length) {
          x.push(b);
          b = b.map(fn$);
          b = b.reduce(fn1$, []);
        }
        x = x.reduce(function(a, b){
          return a.concat(b);
        }, []);
        return x;
        function fn$(node){
          var c, a, b;
          c = [];
          for (a in node) {
            b = node[a];
            if (a !== 'cfg' && b && b.cfg) {
              c.push(b);
            }
          }
          return c;
        }
        function fn1$(a, b){
          return a.concat(b);
        }
      },
      callMethods: {
        render: {
          active: false,
          followPath: true
        },
        init: {
          active: true,
          cleanup: true
        },
        resize: {
          active: true,
          followPath: true
        },
        refresh: {
          active: true,
          followPath: true
        },
        attach: {
          active: true,
          followPath: true
        },
        detach: {
          active: true,
          reverse: true
        },
        finit: {
          active: false,
          reverse: true
        }
      },
      call: function(M){
        return function(method, id){
          var param, res$, i$, to$, opts, list, this$ = this;
          id == null && (id = '');
          res$ = [];
          for (i$ = 2, to$ = arguments.length; i$ < to$; ++i$) {
            res$.push(arguments[i$]);
          }
          param = res$;
          if (!param.length) {
            param = false;
          }
          if (!(opts = this.callMethods[method])) {
            return false;
          }
          if (!(list = this.list(id))) {
            return false;
          }
          if (opts.cleanup) {
            list.forEach(function(node){
              var a, b;
              a = node.cfg;
              if (!a.node) {
                return;
              }
              b = a.context ? a.context.cfg : a;
              if (b.parent.cfg.nav.id === b.id) {
                return;
              }
              a.node = null;
            });
          }
          list = list.reduce(function(a, node){
            var b;
            if (!(method in node.cfg)) {
              return a;
            }
            if (opts.followPath && node.cfg.parent) {
              b = node;
              while (b.cfg.parent && b.cfg.parent.cfg.id !== 'ui') {
                b = b.cfg.parent;
              }
              if (b.cfg.id !== M[0]) {
                return a;
              }
            }
            if (opts.active && !node.cfg.node) {
              return a;
            }
            a.push(node);
            return a;
          }, []);
          if (!list.length) {
            return true;
          }
          if (opts.reverse) {
            list.reverse();
          }
          return list.every(function(node){
            var a;
            a = param
              ? node.cfg[method].apply(node, param)
              : node.cfg[method].call(node);
            if (!a) {
              this$.log(method + ' failed', node);
            }
            return a;
          });
        };
      },
      hide: function(id, onComplete){
        var list, a, b;
        if (!id || !(list = this.list(id)) || !list.length) {
          onComplete();
          return;
        }
        list = list.slice(1);
        list.reverse();
        a = new TimelineLite({
          paused: true
        });
        b = '';
        list.forEach(function(node){
          var c;
          if (!(node = this.cfg.node)) {
            return;
          }
          c = new TimelineLite({
            paused: true
          });
          GSAP.add(c, node, this.cfg.hide);
          if (!b || b !== 'L' + this.cfg.level) {
            b = 'L' + this.cfg.level;
            a.addLabel(b);
          }
          a.add(c.play(), b);
        });
        a.add(onComplete);
        a.play();
      },
      show: function(id1, id0, onComplete){
        var x, node, parent, c, list, a, b;
        x = new TimelineLite({
          paused: true
        });
        x.addLabel('turn');
        node = this.el[id1].cfg;
        parent = node.parent;
        if (id0 && (c = parent.cfg.parent)) {
          list = [parent];
          for (a in c) {
            b = c[a];
            if (a !== 'cfg' && b.cfg) {
              if (!b.cfg.node || a === parent.cfg.id) {
                continue;
              }
              list.push(b);
            }
          }
          list.forEach(function(parent){
            var el0, el1, turn, flag, a, old;
            el0 = parent[id0];
            el1 = parent[id1];
            turn = parent.cfg.turn;
            flag = !!parent.cfg.context;
            if (flag && (!el0 || !el0.render) && (!el1 || !el1.render)) {
              if (turn) {
                a = new TimelineLite({
                  paused: true
                });
                GSAP.add(a, parent.cfg.node, turn);
                x.add(a.play(), 'turn');
              }
              return;
            }
            if (flag) {
              if (el0) {
                old = el0.node;
              }
            } else {
              el0 = el0.cfg;
              el1 = el1.cfg;
              old = parent.cfg.node.query('#' + id0, 0, true)[0];
            }
            if (!turn) {
              old && x.add(function(){
                parent.cfg.node.child.remove(old);
                if (el0.node) {
                  delete el0.node;
                }
              });
              return;
            }
            turn = {
              on: el1 && el1.turn
                ? el1.turn.on
                : turn.on,
              off: el0 && el0.turn
                ? el0.turn.off
                : turn.off
            };
            if (el1) {
              a = new TimelineLite({
                paused: true
              });
              if (!old && parent.cfg.show) {
                GSAP.add(a, parent.cfg.node, parent.cfg.show);
              }
              !flag && x.add(function(){
                el1.node.style.display = null;
              }, 'turn');
              GSAP.add(a, el1.node, turn.on);
              x.add(a.play(), 'turn');
            }
            if (old) {
              a = new TimelineLite({
                paused: true
              });
              GSAP.add(a, old, turn.off);
              if (!el1 && parent.cfg.hide) {
                GSAP.add(a, parent.cfg.node, parent.cfg.hide);
              }
              x.add(a.play(), 'turn');
              x.add(function(){
                parent.cfg.node.child.remove(old);
                delete el0.node;
              });
            }
          });
        }
        list = this.list(id1);
        if (id0) {
          list = list.slice(1);
        }
        list = list.reduce(function(a, b){
          if (b.cfg.node) {
            a.push(b);
          }
          return a;
        }, []);
        a = '';
        list.forEach(function(elem){
          var b, c;
          b = elem.cfg;
          c = new TimelineLite({
            paused: true
          });
          c.add(function(){
            var c;
            if (b.context) {
              c = elem[b.nav.id];
              if (c) {
                c.node.style.display = null;
              }
            } else {
              b.node.style.display = null;
            }
          });
          GSAP.add(c, b.node, b.show);
          if (!a || a !== 'L' + b.level) {
            a = 'L' + b.level;
            c.addLabel(a);
          }
          x.add(c.play(), a);
        });
        x.add(onComplete);
        x.play();
      },
      log: function(msg, node){
        var a;
        a = [];
        while (node) {
          a.push(node.cfg.id);
          node = node.cfg.parent;
        }
        if (a.length) {
          msg = '«' + a.reverse().join('.') + '» ' + msg;
        }
        console.log('w3ui.app: ' + msg);
      }
    };
    PRESENTER = {
      init: function(M, V, P){
        var name, ref$, method;
        for (name in ref$ = PRESENTER) {
          method = ref$[name];
          if (typeof method === 'function' && name !== 'init') {
            P[name] = method(M, V, P);
          }
        }
        P.update(function(){
          window.addEventListener('resize', P.resize.bind(P));
          return true;
        });
        return true;
      },
      update: function(M, V, P){
        var busy, lock, nav, id0, id1, level, rid, cancelThread, thread;
        busy = false;
        lock = false;
        nav = null;
        id0 = '';
        id1 = '';
        level = 0;
        rid = '';
        cancelThread = function(msg){
          if (msg) {
            console.log(msg);
          }
          lock = false;
          busy = false;
          return null;
        };
        thread = [
          function(){
            return !busy;
          }, function(){
            var i$, ref$, len$, b, a;
            busy = true;
            if (nav) {
              for (i$ = 0, len$ = (ref$ = nav).length; i$ < len$; ++i$) {
                b = i$;
                a = ref$[i$];
                if (a !== M[b]) {
                  id0 = a;
                  id1 = M[b];
                  level = b;
                  break;
                }
              }
            } else {
              id1 = M[0];
            }
            if (id0 === id1) {
              return cancelThread();
            }
            if (!(a = V.el[id1])) {
              M[level] = id0;
              return cancelThread('"' + id1 + '" not found');
            }
            b = a.cfg.level - 2;
            if (b < 0) {
              b = 0;
            }
            while (a.cfg.level > b) {
              a = a.cfg.parent;
            }
            rid = a.cfg.id;
            if (!V.call('detach')) {
              return cancelThread('detach failed');
            }
            if (id0) {
              lock = true;
              V.hide(id0, function(){
                lock = false;
              });
            }
            if (!V.call('finit', id1)) {
              return cancelThread('finit failed');
            }
            return true;
          }, function(){
            return !lock;
          }, function(){
            if (!V.call('render', rid, id0)) {
              return cancelThread('render failed');
            }
            if (!V.call('init')) {
              return cancelThread('init failed');
            }
            lock = true;
            V.show(id1, id0, function(){
              lock = false;
            });
            return true;
          }, function(){
            return !lock;
          }, function(){
            ['resize', 'refresh', 'attach'].forEach(function(a){
              return V.call(a);
            });
            nav = M.nav.map(function(a){
              return a.id;
            });
            busy = false;
            return true;
          }
        ];
        return function(onComplete){
          THREAD(onComplete ? thread.concat(onComplete) : thread);
        };
      },
      refresh: function(M, V, P){
        return function(id){
          id == null && (id = M[0]);
          V.call('refresh', id);
          V.call('detach', id);
          V.call('attach', id);
          delete P.event.busy;
        };
      },
      resize: function(M, V, P){
        return function(force){
          var me;
          me = P.resize;
          if (!force && me.timer) {
            window.clearTimeout(me.timer);
            me.timer = window.setTimeout(me.bind(P), 250);
            return;
          }
          if (!V.call('resize')) {
            console.log('w3ui.app: resize failed');
          }
        };
      },
      event: function(M, V, P){
        return function(conf, event){
          var me, cfg, dat, a;
          me = P.event;
          cfg = this.cfg;
          if (conf.preventDefault) {
            event.preventDefault();
          }
          if (!cfg.detach || !(dat = cfg.detach.data)) {
            return true;
          }
          if (me.busy) {
            if (!conf.delayed) {
              return true;
            }
            event.stopPropagation();
            a = !!me.delayed;
            me.delayed = me.bind(this, conf, event);
            if (a) {
              return false;
            }
            if (typeof me.busy === 'object') {
              me.busy.timeScale(2);
            }
            w3ui.THREAD([function(){
              if (me.busy) {
                return false;
              }
              me.delayed();
              delete me.delayed;
              return true;
            }]);
            return false;
          }
          event.conf = conf;
          event.data = dat;
          me.busy = P.react.call(this, M, V, P, event);
          return true;
        };
      }
    };
    return function(mvp){
      var M, V, P;
      if (!('M' in mvp) || !('V' in mvp) || !('P' in mvp)) {
        console.log('w3ui.app: incorrect parameter');
        return false;
      }
      M = PROXY(CLONE(import$(MODEL.data, mvp.M)), MODEL.proxy);
      V = import$(clone$(VIEW), mvp.V);
      P = import$(clone$(PRESENTER), mvp.P);
      document.addEventListener('DOMContentLoaded', function(){
        if (!V.init(M, V, P)) {
          console.log('w3ui.app: failed to initialize view');
          return;
        }
        if (!P.init(M, V, P)) {
          console.log('w3ui.app: failed to initialize presenter');
          return;
        }
      });
      return true;
    };
  }();
  DEP = {
    CLONE: CLONE,
    PROXY: PROXY,
    THREAD: THREAD,
    GSAP: GSAP,
    app: APP,
    clearObject: function(obj){
      var k, own$ = {}.hasOwnProperty;
      for (k in obj) if (own$.call(obj, k)) {
        delete obj[k];
      }
    }
  };
  return new Proxy(API, WIDGET.proxy);
}();
/***/
w3ui && (w3ui.accordion = {
  /* {{{
  * TODO:
  */
  options: {
    panels: null,
    panelsAutoSize: true,
    render: Mustache.render,
    template: {
      title: '',
      content: ''
    }
  },
  data: {
    panels: [],
    activePanel: []
  },
  animation: {
    show: [{
      node: null,
      duration: 0.2,
      to: {
        className: '+=show',
        ease: Power2.easeOut
      }
    }]
  },
  setOption: function(key, val){
    switch (key) {
    case 'panels':
      this.panels = w3ui.CLONE(val);
    }
    return val;
  },
  init: function(){
    this.panels();
    return true;
  },
  create: function(){
    if (!this.panels.create()) {
      this.log('failed to create panels');
      return false;
    }
    return this.refresh();
  },
  destroy: function(){
    this.panels.destroy();
  },
  attach: function(){
    return true;
  },
  refresh: function(){
    this.panels.refresh();
    return true;
  },
  panels: function(){
    var setData, initData, createPanelNodes, listPanels, createPanels, destroyPanels, refreshPanels, getPanel, api, this$ = this;
    setData = function(data){
      if (!data) {
        this$.data.panels = null;
        return;
      }
      initData(data);
      return this$.data.panels = data;
    };
    initData = function(data, parent){
      var i$, len$, index, el;
      parent == null && (parent = null);
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        index = i$;
        el = data[i$];
        el.parent = parent;
        el.level = parent ? parent.level + 1 : 0;
        if (!el.id) {
          el.id = el.level + '#' + index;
        }
        if (el.active) {
          this$.data.activePanel.push(el.id);
        }
        if (typeof el.val === 'object') {
          initData(el.val, el);
        }
      }
    };
    createPanelNodes = function(data, parent){
      var i$, len$, index, el, a, b;
      data == null && (data = this$.data.panels);
      parent == null && (parent = this$.node[0]);
      if (!data) {
        return false;
      }
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        index = i$;
        el = data[i$];
        if (!el.parentNode) {
          el.parentNode = parent;
        }
        if (!el.node) {
          a = document.createElement('div');
          b = document.createElement('div');
          el.node = w3ui([a, b]);
          a = el.node[0];
          b = el.node[1];
          a.prop.dataId = el.id;
          a['class'] = 'l' + el.level + ' n' + index + ' title';
          b['class'] = 'l' + el.level + ' n' + index + ' content';
          if (index === data.length - 1) {
            a['class'].add('last');
          }
        }
        if (typeof el.val === 'object') {
          if (!createPanelNodes(el.val, el.node[1])) {
            return false;
          }
        }
      }
      return true;
    };
    listPanels = function(data, list){
      var i$, len$, el, group, a, b;
      data == null && (data = this$.data.panels);
      list == null && (list = []);
      if (!data) {
        return list;
      }
      list = list.concat(data);
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        el = data[i$];
        if (Array.isArray(el.val)) {
          group = el.val;
          list = list.concat(group);
        }
      }
      do {
        a = [];
        for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
          b = data[i$];
          if (Array.isArray(b.val)) {
            a.push(b);
          }
        }
        data = [];
        for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
          b = a[i$];
          list = list.concat(b.val);
          data = data.concat(b.val);
        }
      } while (data.length);
      return list;
    };
    createPanels = function(){
      var list, i$, len$, a;
      if (!createPanelNodes()) {
        return false;
      }
      if (!(list = listPanels())) {
        return true;
      }
      this$.node.child.remove();
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        a = list[i$];
        a.parentNode.child.add(a.node);
      }
      return true;
    };
    destroyPanels = function(){
      var list, i$, len$, a;
      if (!(list = listPanels())) {
        return;
      }
      list.reverse();
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        a = list[i$];
        a.parentNode.child.remove(a.node);
      }
      this$.node.child.remove();
    };
    refreshPanels = function(data){
      var list, opt, ani, i$, len$, el, a, b;
      if (!(list = listPanels(data))) {
        return;
      }
      opt = this$.options;
      ani = this$.animation;
      for (i$ = 0, len$ = list.length; i$ < len$; ++i$) {
        el = list[i$];
        a = el.node[0];
        b = el.node[1];
        switch (typeof el.name) {
        case 'string':
          a.html = el.name;
          break;
        case 'object':
          if (opt.render && opt.template.title) {
            a.html = opt.render(opt.template.title, el.val);
          }
        }
        switch (toString$.call(el.val).slice(8, -1)) {
        case 'String':
          b.html = el.val;
          break;
        case 'Array':
          break;
        case 'Object':
          if (opt.render && opt.template.content) {
            b.html = opt.render(opt.template.content, el.val);
          }
        }
      }
      a = [];
      this$.data.activePanel.forEach(function(id){
        var b;
        if (b = getPanel(id)) {
          a = a.concat(b.node.nodes);
        }
      });
      ani.show[0].node = a;
    };
    getPanel = function(id, data){
      var i$, len$, el, a;
      data == null && (data = this$.data.panels);
      for (i$ = 0, len$ = data.length; i$ < len$; ++i$) {
        el = data[i$];
        if (el.id === id) {
          return el;
        }
        if (toString$.call(el.val).slice(8, -1) === 'Array') {
          if (a = getPanel(id, el.val)) {
            return a;
          }
        }
      }
      return null;
    };
    api = {
      create: createPanels,
      destroy: destroyPanels,
      refresh: refreshPanels,
      $proxy: {
        get: function(api, key){
          if (key in api) {
            return api[key];
          }
          return null;
        }
      }
    };
    api = w3ui.PROXY(api, api.$proxy);
    Object.defineProperty(this, 'panels', {
      get: function(){
        return api;
      },
      set: setData
    });
  }
  /**** }}} */
});
w3ui && (w3ui.pointer = {
  /* {{{
  * TODO:
  */
  options: {
    drag: false,
    dragButton: 0,
    dragDistance: 1
  },
  data: {
    drag: false,
    event: null
  },
  create: function(){
    var me, a, b;
    me = this;
    a = this.element;
    b = this.namespace;
    a.on("mousedown" + b, function(event){
      return me.event("down", event);
    });
    a.on("click" + b, function(event){
      return me.event("click", event);
    });
    return true;
  },
  destroy: function(){
    this.element.off(this.namespace);
    this.document.off(this.namespace);
    return true;
  },
  attach: function(){
    return true;
  },
  detach: function(){
    return true;
  },
  event: function(handler, event){
    var a;
    if (this.options.disabled || this.core.options.disabled) {
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    if (a = this[handler](event)) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }
    return a;
  }
  /*
  down: (event) -> # {{{
      # prepare
      me = @
      d  = @data
      o  = @options
      # check if drag enabled
      if not o.drag
          return @api.down.apply @core, [event]
      # drag only at specified mouse button
      if o.which and event.which != o.which
          return false
      # check drag state
      if d.drag
          # disable next click event
          d.click = false
          # cancel drag
          @up event
      # save event
      d.event = event
      # start the DRAG
      if d.drag = @api.down.apply @core, [event]
          # prepare
          a = @document
          b = @namespace
          # set handlers
          a.on "mousemove" + b, (event) -> me.event "move", event
          a.on "mouseup" + b, (event) -> me.event "up", event
          # set delay timer
          o.delay and d.delay = BOUNCE {time: o.delay}, !->
              d.delay = 0
      # return state
      d.drag
  # }}}
  up: (event) -> # {{{
      # prepare
      d = @data
      o = @options
      # check
      if not d.drag
          @api.up.apply @core, [event]
          return true
      # stop the DRAG
      d.drag = false
      # detach handlers
      @document.off @namespace
      # reset delay timer
      if o.delay and d.delay
          window.clearTimeout d.delay
          d.delay = 0
      # call handler
      @api.up.apply @core, [event]
      true
  # }}}
  move: (event) -> # {{{
      # prepare
      d = @data
      o = @options
      # check if drag operation enabled and started
      if not o.drag or not d.drag
          # no, call standard handler
          return @api.move.apply @core, [event]
      # stop drag at wrong mouse button
      if event.which != d.event.which
          @up event
          return true
      # check delay
      return true if d.delay
      # check distance
      if o.distance
          a = Math.abs d.event.pageX - event.pageX
          b = Math.abs d.event.pageY - event.pageY
          a = Math.max a, b
          return true if a < o.distance
      # call handler
      if not @api.drag.apply @core, [event]
          # stop drag
          @up event
      # complete
      true
  # }}}
  click: (event) -> # {{{
      # prepare
      d = @data
      # check click enabled
      if not d.click
          # cancel it
          d.click = true
          # dont send it anywhere
          event.stopImmediatePropagation!
      else
          # call handler
          @api.click.apply @core, [event]
      # complete
      true
  # }}}
  */,
  api: {
    down: function(e){
      return true;
    },
    drag: function(e){
      return true;
    },
    up: function(e){},
    click: function(e){},
    move: function(e){
      return true;
    }
  }
  /**** }}} */
});
w3ui && (w3ui.slider = {
  /* {{{
  * rev90, TODO:
  * task #10: slider constructor
  * negative values
  * large values
  * multiple handles >2
  * multiple ranges, minmax, array
  * <-(arrow capture keys)-> with acceleration
  * GSAP animation
  * better sync for handle/range animation
  * new standard with slash(/) syntax in border-radius
  * revise relative option
  * optimize range refresh routine
  * image slider
  */
  options: {
    _order: ['minmax', 'count', 'step', 'margin', 'value'],
    minmax: [0, 100],
    count: 1,
    step: 1,
    margin: [],
    value: [0],
    range: [0, 0],
    orientation: true,
    strict: false,
    inner: false,
    round: 0,
    tabindex: -1,
    toggle: false,
    k_pages: 5,
    k_range: ['ctrlKey', 'HOME', 'END'],
    k_value: ['ctrlKey', 'LEFT', 'RIGHT']
  },
  data: {
    handles: null,
    handleIndex: -1,
    maxCount: 10,
    min: 0,
    max: 100,
    shift: 0,
    size: 100,
    margin: 0,
    val: null,
    scale: null
  },
  create: function(){
    var data, opts, a, b, c, i$, to$, d, len$;
    data = this.data;
    opts = this.options;
    a = this.node.query('');
    b = a.length;
    c = opts.count;
    if (b !== c) {
      if (b > c) {
        for (i$ = b - 1, to$ = c - 1; i$ <= to$; ++i$) {
          d = i$;
          this.node.child.remove(a[d].node);
        }
      } else {
        for (i$ = 0, to$ = c - b; i$ <= to$; ++i$) {
          d = i$;
          a = document.createElement('div');
          this.node.child.add(a);
        }
      }
      a = this.node.query('');
    }
    a['class'].add('ui-' + this.name + '-handle');
    a.prop.tabindex = opts.tabindex;
    for (i$ = 0, len$ = a.length; i$ < len$; ++i$) {
      c = i$;
      b = a[i$];
      b.prop.dataIndex = c + 1;
    }
    a.size = this.getHandleSize();
    a.pos = d.handleSize.map(function(){
      return {
        left: 0,
        top: 0
      };
    });
    d.handles = a;
    if (d.range) {
      if (!d.range$) {
        b = [];
        for (i$ = 0, to$ = d.range.length; i$ <= to$; ++i$) {
          a = i$;
          if (d.range[a] >= 0) {
            a = document.createElement('div');
            b.push(a);
            this.element.append(a);
          }
        }
        b = $(b);
        b.addClass(this.name + "-range");
        b.each(function(index){
          return b.eq(index).addClass('n' + (index + 1));
        });
        d.range$ = $(b);
      }
      d.range$.css({
        left: "",
        top: ""
      });
      a = ['min', 'max'];
      b = d.range.length - 1;
      o.direction && a.reverse();
      d.range[0] < 0 && d.range.element.eq(0).addClass(a[0]);
      d.range[b] < 0 && d.range.element.eq(b).addClass(a[1]);
    } else if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    this.refresh(true);
    return true;
  },
  setOption: function(key, val){
    var dat, opt, msg, a, i$, ref$, to$, b, c, v, len$, m, this$ = this;
    dat = this.data;
    opt = this.options;
    msg = function(msg){
      return this$.log('incorrect option «' + key + '», ' + msg);
    };
    switch (key) {
    case 'minmax':
      if (!('length' in val)) {
        msg('wrong type');
        return;
      }
      if (val.length !== 2) {
        msg('incorrect length');
        return;
      }
      val = [Math.round(val[0]), Math.round(val[1])];
      if (val[0] === val[1]) {
        msg('values cant be equal');
        return;
      }
      a = val.slice();
      dat.reversed = a[0] < a[1];
      if (dat.reversed) {
        a.reverse();
      }
      dat.shift = a[0] < 0 ? -a[0] : 0;
      if (dat.shift) {
        a[0] = 0;
        a[1] = a[1] + dat.shift;
      }
      dat.min = a[0];
      dat.max = a[1];
      dat.size = a[1] - a[0];
      break;
    case 'count':
      val = Math.round(val);
      if (val <= 0) {
        msg('must be greater than zero');
        val = 1;
      }
      if (val > dat.maxCount) {
        msg('must be less than ' + dat.maxCount);
        val = dat.maxCount;
      }
      if (val > opt.count) {
        for (i$ = opt.count; i$ <= val; ++i$) {
          a = i$;
          opt.margin.push(0);
          opt.value.push((ref$ = opt.value)[ref$.length - 1]);
          opt.range.push(0);
        }
      } else if (val < opt.count) {
        for (i$ = val, to$ = opt.count; i$ <= to$; ++i$) {
          a = i$;
          opt.margin.pop();
          opt.value.pop();
          opt.range.pop();
        }
      }
      break;
    case 'step':
      val = Math.round(val);
      if (val <= 0) {
        msg('should be positive');
        val = 1;
      }
      a = Math.round((dat.max - dat.min) / opt.count);
      if (val > a) {
        msg('must be less than ' + a);
        val = a;
      }
      break;
    case 'margin':
      val = val.map(function(val){
        var a;
        val = Math.round(val);
        if (val < 0) {
          msg('should be positive');
          val = 0;
        }
        if ((a = val % opt.step) !== 0) {
          msg('should be aligned with the step ' + opt.step);
          val -= a;
        }
        return val;
      });
      a = val.reduce(function(a, b){
        return a + b;
      }, 0);
      b = dat.max - dat.min - a;
      c = Math.round(a / opt.step);
      if (b <= 0 || c < opt.count) {
        msg('the total margin ' + a + ' is too big');
        return;
      }
      dat.margin = a;
      break;
    case 'value':
      if (val.length < opt.count) {
        msg('minimum ' + opt.count + ' items required');
        return;
      }
      if (val.length > opt.count) {
        msg('limited by ' + opt.count);
        val = val.slice(0, opt.count);
      }
      v = val.map(function(v){
        return Math.round(v);
      }).sort(function(a, b){
        if (a < b) {
          return -1;
        } else {
          return 1;
        }
      });
      dat.shift && (v = v.map(function(v){
        return v + dat.shift;
      }));
      for (i$ = 0, len$ = v.length; i$ < len$; ++i$) {
        b = i$;
        a = v[i$];
        if (a < dat.min) {
          v[b] = dat.min;
        }
        if (a > dat.max) {
          v[b] = dat.max;
        }
      }
      if (dat.margin) {
        m = opt.margin;
        for (i$ = 0, len$ = m.length; i$ < len$; ++i$) {
          b = i$;
          a = m[i$];
          if (a > 0) {
            if ((c = v[b + 1] - v[b]) >= a) {
              continue;
            }
            c = a - c;
            a = v[b] - c;
            if ((b === 0 && a >= dat.min) || v[b - 1] + m[b - 1] >= a) {
              v[b] = a;
              continue;
            }
            a = v[++b] + c;
            if ((b >= m.length && a <= dat.max) || v[b + 1] - a >= m[b]) {
              v[b] = a;
              continue;
            }
            msg('failed to apply margins');
            return;
          }
        }
      }
      dat.val = v;
      break;
    case 'range':
      val = val.map(function(val){
        return !!val;
      });
      a = opt.count + 1;
      while (val.length < a) {
        val.push(false);
      }
      if (val.length > a) {
        val.slice(0, a);
      }
      break;
    case 'toggle':
      val = !!val;
      if (opt.count === 1 && val) {
        msg('supported only for a single handle');
        val = false;
      }
      break;
    case 'orientation':
      a = val ? 'horizontal' : 'vertical';
      this.node['class'].add('ui-' + this.name + '-' + a);
      break;
    case 'tabindex':
      if (val !== null) {
        val = isNaN(a = parseInt(val)) ? null : a;
      }
      this.node.prop.tabindex = null;
      break;
    default:
      msg('not implemented');
      return;
    }
    return val;
  },
  refresh: function(init){
    var d, o, a, b, c;
    d = this.data;
    o = this.options;
    a = this.element[0];
    a = {
      left: a.offsetLeft,
      top: a.offsetTop,
      height: a.offsetHeight,
      width: a.offsetWidth,
      h: a.clientHeight,
      w: a.clientWidth,
      margin: 0,
      handle: 0
    };
    this.element.parents().each(function(index, el){
      a.left += el.scrollLeft;
      a.top += el.scrollTop;
    });
    b = o.orientation
      ? [a.w(a.h)]
      : [a.h(a.w)];
    if (d.margin) {
      c = d.margin / d.size;
      a.margin = b[0] * c;
    }
    a.handle = o.inner
      ? b[1]
      : 1.5 * b[1];
    c = o.round ? this.cssValue(b[1] / 2) : "";
    this.element.css("border-radius", c);
    d.scale = a;
    a = [];
    d.handles.each(function(index, node){
      var b;
      b = {
        w: node.clientWidth,
        h: node.clientHeight,
        width: node.offsetWidth,
        height: node.offsetHeight,
        w_gap: 0,
        h_gap: 0
      };
    });
    /***
    # определим классификаторы фиксированной оси и шкалы
    a = ["h", "height", "innerHeight", "outerHeight", "h_gap"];
    b = ["w", "width",  "innerWidth",  "outerWidth",  "w_gap"];
    @orientation && (d = a, a = b, b = d);
        # ..
        # prepare
        #node = d.handles.eq index
        # добавляем индекс
        #node.data "ui-slider-handle-index", index
        # определяем зазор
        d[a[4]] = el[a[3]](true) - d[a[0]];
        d[b[4]] = el[b[3]](true) - d[b[0]];
        # определяем полный размер ползунка
        # фиксированная ось
        c = @elementSize.handle;# авто-размер
        # в случае, если текущий стиль не конфликтует с опциями,
        # оставляем его, иначе назначаем авто-размер.
        d[a[1]] = (d[a[0]] > 1 && (!@options.inner || d[a[0]] < c)) ?
                (d[a[0]] + d[a[4]]) : c;
        # шкала
        d[b[1]] = (d[b[0]] > 1) ?
                (d[b[0]] + d[b[4]]) : c;
        # определяем внутренний размер
        d[a[0]] = Math.abs(d[a[1]] - d[a[4]]);
        d[b[0]] = Math.abs(d[b[1]] - d[b[4]]);
        # кривизна границ
        c = @options.round;
        if (c > 1)
        {
            # закругленные границы
            # в зависимости от внутреннего размера ползунка на фиксированной оси
            d["border-radius"] = @_cssValue(d[a[0]] / 2);
            # круглый ползунок
            if (c > 2)
            {
                # размеры симметричны (длина == ширина)
                # за основу берем размер на фиксированной оси
                d[b[0]] = d[a[0]];
                d[b[1]] = d[b[0]] + d[b[4]];
                d["border-radius"] = "50%";
            }
        }
        # определим соотношение внутренних размеров
        d.scale = d[b[0]] / d[a[0]]; # плавающая / фиксированная
        # сохраняем
        e[index] = d;
        true
    
    # определяем размер
    
    
    
    e = [];
    
    
    @handles.toArray!forEach(function(el, index) {
    }, this);
    
    
    
    
    # align on fixed axis
    d.handles.each (index, node) !->
        # determine offset (center)
        d = @handleSize[index];
        e = @elementSize[b[0]];
        e = [
            d[b[0]],
            e / 2.0 - d[b[1]] / 2.0,
            e,
            "border-radius"
        ]
        # проверка необходимости
        if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
            Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
        {
            # выполняем позиционирование
            # без анимации
            a = {};
            a[b[1]] = @_cssValue(e[0], e[2]);
            a[b[2]] = @_cssValue(e[1], e[2]);
            if (d[e[3]]) {
                a[e[3]] = d[e[3]];
            }
            node.css(a);
        }
    # ..
    
    
    
    
    
    
    
    
    
    
    
    # ..
    a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
    b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"]
    @orientation && (c = a, a = b, b = c);
    # collect handles
    for (c = [], d = 0; d < @val.length; d++) {
        c[d] = @handles.eq(d);
    }
    # 1. позиционируем на шкале
    # {{{
    # вычисляем полный размер
    d = @handleSize;
    d.full = 0;
    c.forEach(function(node, index) {
        # подготовка
        e = d[index];
        # размер на шкале пропорционален размеру на фиксированной оси
        # внутренний размер
        e[a[0]] = e.scale * e[b[0]];
        # полный размер
        e[a[1]] = e[a[0]] + e[a[5]];
        d.full += e[a[1]];
    });
    # позиционирование
    c.forEach(function(node, index) {
        # обновляем размер
        # без анимации
        d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
        e = {}, e[a[1]] = d;
        node.css(e);
        # обновляем смещение
        # с условной анимацией
        @_refreshHandle(index, !fixedAxis);
    }, this);
    # }}}
    /***/
    this.refreshRange();
    return true;
  },
  addEvents: function(){},
  event: function(){
    return true;
  },
  delEvents: function(){
    this._mouseDestroy();
    this._off(this.handles);
    return $(window).off("resize." + this.eventNamespace);
  },
  destroy: function(){
    var d;
    this.delEvents();
    d = this.data;
    d.handle.remove();
    delete d.handle;
    delete d.handleSize;
    delete d.handleOffset;
    if (d.range$) {
      d.range$.remove();
      delete d.range$;
    }
    return true;
  },
  api: {
    alias: {
      value: ['val', 'value', 'values'],
      range: ['range', 'ranges']
    }
    /***
    value: function(val, index) { # {{{
        var a, b;
        ##
        a = arguments.length;
        if (!a) {
            return @values(0);
        }
        b = typeof val;
        if (b !== "number" && b !== "string") {
            return false;
        }
        if (a === 1) {
            return @values(0, val);
        }
        if (index < 0 || index >= @val.length) {
            return false;
        }
        return @values(index, val);
    },
    # }}}
    values: function(index, val) { # {{{
        var a, b, c;
        ##
        # подготовка
        a = arguments.length;
        b = arguments[0];
        # возвращаем все значения
        if (a === 0) {
            return @_valueRefined(@val, true);
        }
        # сохраняем массив значений
        if (a === 1 && jQuery.isArray(b))
        {
            if (!@_event("change", null, -1, @_valueRefined(b))) {
                return b;
            }
            return @_valueRefined(b, true);
        }
        # сохраняем единственное значение
        if (a === 2)
        {
            b = @_valueRefined(val);
            c = @val.slice!
            c[index] = b;
            return @_event("change", null, index, c) ? b : false;
        }
        # возвращаем единственное значение
        return @_valueRefined(@val[index]);
    },
    # }}}
    range: function(index) { # {{{
        index = arguments.length ? 0 + index : 0;
        return @ranges(index);
    },
    # }}}
    ranges: function() { # {{{
        var a, b, c, d;
        ##
        if (!@_rangeMap) {
            return false;
        }
        # подготовка
        a = arguments.length;
        b = [];
        for (c = 0; c < @_rangeMap.length; c += 2)
        {
            d = [
                @_rangeMap[c],
                @_rangeMap[c + 1]
            ];
            @options.direction && d.reverse!
            d[0] = d[0] < 0 ? @min : @val[d[0]];
            d[1] = d[1] < 0 ? @max : @val[d[1]];
            b.push(Math.abs(d[1] - d[0]));
        }
        # возврат
        if (a === 0) {
            return b;
        }
        a = index < 0 || index >= b.length ? 0 : index;
        return b[a];
    },
    # }}}
    /***/
  },
  cssValue: function(val, scale){
    var a;
    if (scale) {
      a = (100.0 * val / scale).toFixed(5) + "%";
    } else {
      a = Math.round(val) + "px";
    }
    return a;
  }
  /** {{{ **
      # MOUSE
      _mouseEventCoords: function(e) { # {{{
          var a, b, c;
          ##
          # определим относительную позицию указателя
          # вычисляем scroll
          a = {x: e.pageX, y: e.pageY};
          b = @element.parents!
          for (c = 0; c < b.length; c++)
          {
              a.x = a.x + b.eq(c).scrollLeft!
              a.y = a.y + b.eq(c).scrollTop!
          }
          return a;
      },
      # }}}
      _mouseValue: function(coords, capture) { # {{{
          var a, b, c, d, e;
          ##
          # определяем значение шкалы в месте клика
          # в зависимости от ориентации слайдера
          a = @orientation ?
              [coords.y - @elementOffset.top,  "height", "top"] :
              [coords.x - @elementOffset.left, "width", "left"];
          # определяем ближайший ползунок
          d = @_getClosestHandle(coords);
          # определяем длину шкалы
          b = @_getScaleSize(d, true);
          # определяем смещение (относительная позиция)
          c = (a[0] - b[0]) / b[1];
          # инвертируем в случае вертикального слайдера
          @orientation && (c = 1 - c);
          # проверка выхода за границы
          c > 1 && (c = 1);
          c < 0 && (c = 0);
          # вычисляем абсолютное значение
          a = [
              @_valueMin(d),
              @_valueMax(d)
          ];
          b = a[0] + c * (a[1] - a[0]);
          # определяем текущее значение
          c = @options.toggle ?
              @val[d] : @_valueTrim(b, d);
          # определяем шаг
          e = @step ? (@max - @min) / @step : 1;
          # корректировка
          if (Math.abs(@val[d] - c) < 0.0001 &&
              Math.abs(b - c) >= 1 && # минимальный инкремент
              (capture || @options.toggle))
          {
              # значение не может остатся неизменным в случае,
              # когда указатель выбирает точку на шкале
              c = c > b ? c - e : c + e;
          }
          # проверяем выход за границы
          c > a[1] && (c = a[1]);
          c < a[0] && (c = a[0]);
          # возврат
          return c;
      },
      # }}}
      _mouseCapture: function(e) { # {{{
          var a, b;
          ##
          # проверка
          if (@options.disabled) {
              return false;
          }
          # определяем координаты
          a = @_mouseEventCoords(e);
          b = @_mouseValue(a, true);
          # инициируем событие
          return @_event("start", e, @_getClosestHandle(a), b);
      },
      # }}}
      _mouseDrag: function(e) { # {{{
          ##
          if (@options.toggle) {
              return false;
          }
          @_event("slide", e, @_handleIndex, @_mouseValue(@_mouseEventCoords(e)));
          return true;
      },
      # }}}
      _mouseStop: function(event) { # {{{
          @_event("stop", event);
      },
      # }}}
      # POSITIONING
      refreshScale: !-> # {{{
          # prepare
          d = @data
          o = @options
          # determine element size and position
          a = @element.0
          a =
              left:   a.offsetLeft
              top:    a.offsetTop
              height: a.offsetHeight
              width:  a.offsetWidth
              h:      a.clientHeight
              w:      a.clientWidth
              margin: 0
              handle: 0
          # apply scroll offset
          @element.parents!each (index, el) !->
              a.left += el.scrollLeft
              a.top  += el.scrollTop
          # determine scale and fixed axis size
          b = if o.orientation
              then [a.w a.h]
              else [a.h a.w]
          # determine margin size
          if d.margin
              # determine relative value
              c = d.margin / d.size
              # determine absolute value
              a.margin = b.0 * c
          # determine default handle size
          a.handle = if o.inner
              then b.1
              else 1.5 * b.1
          # determine border curvature
          c = if o.round
              then @cssValue b.1 / 2
              else ""
          # apply it
          @element.css "border-radius", c
          # save results
          d.scale = a
      # }}}
      refreshHandles: (fixedAxis) !-> # {{{
          # prepare
          d = @data
          o = @options
          # ..
          a = ["w", "width",  "left", "innerWidth",  "outerWidth",  "w_gap"]
          b = ["h", "height", "top",  "innerHeight", "outerHeight", "h_gap"];
          @orientation && (c = a, a = b, b = c);
          # определяем массив ползунков
          for (c = [], d = 0; d < @val.length; d++) {
              c[d] = @handles.eq(d);
          }
          # 1. позиционируем на шкале
          # {{{
          # вычисляем полный размер
          d = @handleSize;
          d.full = 0;
          c.forEach(function(node, index) {
              # подготовка
              e = d[index];
              # размер на шкале пропорционален размеру на фиксированной оси
              # внутренний размер
              e[a[0]] = e.scale * e[b[0]];
              # полный размер
              e[a[1]] = e[a[0]] + e[a[5]];
              d.full += e[a[1]];
          });
          # позиционирование
          c.forEach(function(node, index) {
              # обновляем размер
              # без анимации
              d = @_cssValue(@handleSize[index][a[0]], @elementSize[a[0]]);
              e = {}, e[a[1]] = d;
              node.css(e);
              # обновляем смещение
              # с условной анимацией
              @_refreshHandle(index, !fixedAxis);
          }, this);
          # }}}
          # 2. позиционируем на фиксированной оси
          # {{{
          if (fixedAxis) {
              c.forEach(function(node, index) {
                  # подготовка
                  # определяем смещение (центровка)
                  d = @handleSize[index];
                  e = @elementSize[b[0]];
                  e = [
                      d[b[0]],
                      e / 2.0 - d[b[1]] / 2.0,
                      e,
                      "border-radius"
                  ]
                  # проверка необходимости
                  if (Math.abs(node[b[3]]() - e[0]) > 0.0001 ||
                      Math.abs(@handleOffset[index][b[2]] - e[1]) > 0.0001)
                  {
                      # выполняем позиционирование
                      # без анимации
                      a = {};
                      a[b[1]] = @_cssValue(e[0], e[2]);
                      a[b[2]] = @_cssValue(e[1], e[2]);
                      if (d[e[3]]) {
                          a[e[3]] = d[e[3]];
                      }
                      node.css(a);
                  }
              }, this);
          }
          # }}}
          # complete
      # }}}
      refreshHandle: function(index, animate) { # {{{
          var a, b, c, d, e;
          ##
          # подготовка
          # в зависимости от ориентации слайдера
          a = @orientation ?
              ["h", "height", "top"] :
              ["w", "width", "left"];
          # определяем ползунок
          b = @handles.eq(index);
          # определяем виртуальное смещение
          c = @_getHandleOffset(index);
          @handleOffset[index][a[2]] = c;
          # определяем флаг анимации
          d = (animate && @options.animate) ?
              @options.animate : 0;
          # определяем время анимации
          if (d)
          {
              # определяем текущую позицию
              e = b.position!
              # определяем дистанцию
              if ((e = Math.abs(c - e[a[2]])) < 0.0001) {
                  # позиционирование не требуется
                  return true;
              }
              # вычисляем относительное время анимации 1..0
              e = e / (@elementSize[a[0]] - @handleSize.full);
              # вычислем абсолютное время
              # отсекаем минимальные значения
              e = d * e / 2;
              d = e <= 50 ? 0 : (e < d ? d : e);
          }
          # определяем параметр
          e = {};
          e[a[2]] = @_cssValue(c, @elementSize[a[0]]);
          # позиционируем
          if (d)
          {
              # с анимацией
              # останавливаем текущую
              b.stop(@eventNamespace, true, @_capture);
              # запуск
              a = this;
              b.animate(e, {
                  duration: d,
                  queue: @eventNamespace,
                  step: function(now, fx) {
                      # на каждом шаге анимации
                      # обновляем диапозон с текущим значением ползунка
                      a._refreshRange(a.handleOffset.map(function(val, idx) {
                          return idx === index ? b.position() : val;
                      }));
                  },
                  complete: function() {
                      # после завершения
                      a._refreshRange!
                  }
              }).dequeue(@eventNamespace);
          }
          else
          {
              # без анимации
              # останавливаем текущую анимацию
              if (@options.animate) {
                  b.stop(@eventNamespace, true, false);
              }
              # обновляем
              b.css(e);
              @_refreshRange!
          }
          return true;
      },
      # }}}
      refreshRange: function(queryPosition) { # {{{
          var a, b, c, d, e;
          ##
          # проверка
          if (!@_rangeMap) {
              return true;
          }
          # подготовка
          a = ["left", "width",  "w", "w_gap",    "h_gap", "h", "height","top"];
          @orientation && a.reverse!
          ##
          # 1. на шкале
          # определяем начальную/конечную точки
          b = @_rangeMap.slice!
          # инвертируем при необходимости
          c = [
              @orientation,
              @options.direction,
              @options.range === true
          ];
          if ((c[0] && (!c[1] || c[2])) ||    # вертикаль
              (!c[0] && (c[1] && !c[2])))     # горизонталь
          {
              b.reverse!
          }
          # диапазон
          # определяем позиции точек
          c = 0;
          d = 0;
          b = b.map(function(val, idx) {
              ##
              if (val < 0)
              {
                  # граница
                  # определим параметры связанного ползунка
                  val = idx ? b[idx - 1] : b[idx + 1];
                  val = @handleSize[val];
                  d = val[a[3]];
                  c = val[a[1]] - d;
                  d = d / 2;
                  # определим позицию
                  e = idx ? @elementSize[a[2]] : 0;
                  # добавляем зазор ползунка,
                  # в случае, если его внутренний размер меньше
                  # размера слайдера на фиксированной оси
                  if (val[a[5]] <= @elementSize[a[5]]) {
                      e += (idx ? -1 : 1) * d;
                  }
                  else
                  {
                      # ползунок больше слайдера,
                      # отступ не нужен
                      d = 0;
                  }
              }
              else
              {
                  # ползунок
                  # определим позицию
                  e = queryPosition ?
                      @handles.eq(val).position() : @handleOffset[val];
                  e = e[a[0]];
                  # корректируем
                  # небольшой отступ в зависимости от позиции ползунка
                  val = @handleSize[val];
                  e += (idx & 1) ?
                      (val[a[1]] - val[a[3]] / 2) : val[a[3]] / 2;
              }
              return e;
          }, this);
          # определяем размер
          b[1] = Math.abs(b[1] - b[0]);
          e = @elementSize[a[2]];
          if (c && b[1] < c - 2 * d)
          {
              # если диапазон меньше чем один из ползунков,
              # убираем его.. (граничные случаи)
              b[1] = 0;
          }
          else if (b[1] > e - 2 * d)
          {
              # диапазон не должен выходить за пределы шкалы
              b[0] = d;
              b[1] = e - 2 * d;
          }
          b[2] = d;
          d = {};
          d[a[0]] = @_cssValue(b[0], e);
          d[a[1]] = @_cssValue(b[1], e);
          ##
          # 2. на фиксированной оси
          # определяем наименьший внутренний размер
          a.reverse!
          e = @elementSize[a[2]];
          c = @_rangeMap.map(function(val, index) {
              # шкала || ползунок
              return (val < 0) ? e : @handleSize[val][a[2]];
          }, this);
          c[1] = Math.min(c[0], c[1], e);
          # определяем смещение (центровка)
          c[0] = c[1] < e ?  (e / 2 - c[1] / 2) : 0;
          # сохраняем
          d[a[0]] = @_cssValue(c[0], e);
          d[a[1]] = @_cssValue(c[1], e);
          ##
          # кривизна границ
          c[2] = "";
          if (@options.round) {
              if (@options.round > 1)
              {
                  # полное скругление
                  c[2] = @_cssValue(c[1] / 2);
              }
              else if (b[2] < e)
              {
                  # скругление в случае когда прямоугольный ползунок
                  # входит в зону скругления шкалы
                  # вычислим радиус
                  e = e / 2;
                  e = (e - b[2]) / e;# относительное значение
                  e = (c[1] / 2) * e;# абсолютное
                  c[2] = @_cssValue(e);
                  # дополнительный радиус,
                  # когда радиус на шкале становится меньше радиуса
                  # на фиксированной оси (NEW syntax, future support?)
                  if (b[1] / 2 < e) {
                      c[2] = c[2] + " / " + @_cssValue(b[1] / 2);
                  }
              }
          }
          d["border-radius"] = c[2];
          # позиционируем
          @_range.css(d);
          return true;
      },
      # }}}
      # UTILITY
      _getHandleOffset: function(index) { # {{{
          var a, b, c, d;
          ##
          # подготовка
          if (index === 0)
          {
              a = @min;
              b = @max;
          }
          else
          {
              a = @_valueMin(index);
              b = @_valueMax(index);
          }
          # определяем значение
          c = @val[index];
          # +margin
          # корректируем
          if ((d = @options.margin) && !(index & 1))
          {
              c = c + d;
              a = a + d;
          }
          # определяем относительное значение
          c = a === b ? 1 : (c - a) / (b - a);
          # определим размер виртуальной шкалы
          b = @_getScaleSize(index);
          # определим позицию на виртуальной шкале
          # инвертируем значение в случае вертикального слайдера
          c = c * b[1];
          @orientation && (c = b[1] - c);
          # центрируем ползунок относительно позиции
          a = @handleSize[index];
          c = c - (@orientation ? a.height : a.width) / 2;
          # возврат
          return c + b[0];
      },
      # }}}
      _getScaleSize: function(index, virtual) { # scale size and offset {{{
          var a, b, c, d, e;
          ##
          # виртуальная шкала привязана к конкретному ползунку
          # в зависимости от ориентации слайдера
          a = @orientation ?
              ["height", "top", "h"] :
              ["width", "left", "w"];
          # определим размер шкалы
          e = @elementSize[a[2]];
          if (index > 0 || virtual)
          {
              # виртуальная шкала (шкала отдельного ползунка)
              # #1
              # предыдущий элемент, начальное смещение
              c = index - 1;
              if (c < 0)
              {
                  b = @orientation ? e : 0;
              }
              else
              {
                  # соседний ползунок
                  b = @handleOffset[c][a[1]];
                  # корректируем
                  if (!@orientation) {
                      if (@options.strict) {
                          b = b + @handleSize[c][a[0]];
                      }
                      else {
                          b = b + @handleSize[c][a[0]] / 2;
                      }
                  }
                  else if (!@options.strict) {
                      b = b + @handleSize[c][a[0]] / 2;
                  }
              }
              # #2
              # определим конечное смещение
              c = index + 1;
              if (c >= @val.length) {
                  d = @orientation ? 0 : e;
              }
              else
              {
                  # соседний ползунок
                  d = @handleOffset[c][a[1]];
                  # корректируем
                  if (@orientation)
                  {
                      if (@options.strict) {
                          d = d + @handleSize[c][a[0]];
                      }
                      else {
                          d = d + @handleSize[c][a[0]] / 2;
                      }
                  }
                  else if (!@options.strict) {
                      d = d + @handleSize[c][a[0]] / 2;
                  }
              }
              # инвертируем значения для вертикального слайдера
              if (@orientation) {
                  a[3] = d, d = b, b = a[3];
              }
          }
          else
          {
              # вся шкала
              # только для первого элемента
              b = 0;
              d = e;
              if (@options.strict)
              {
                  # определяем размер остальных ползунков
                  # не учитываем их на шкале
                  for (c = 1; c < @val.length; c++) {
                      b += @handleSize[c][a[0]];
                  }
                  !@orientation && (d = d - b, b = 0);
              }
          }
          if (@options.strict)
          {
              # точный слайдер сдвигает ползунки внутрь шкалы
              a = @handleSize[index][a[0]] / 2.0;
              b = b + a;
              d = d - a;
          }
          # возврат [начало, размер шкалы, конец]
          return [b, d - b, d];
      },
      # }}}
      _getClosestHandle: function(coords) { # {{{
          var a, b, c, d;
          ##
          # определяем ближайший ползунок
          # при слайдинге, выбираем перетаскиваемый
          if (@_capture) {
              return @_handleIndex;
          }
          # возвращаем индекс единственного ползунка
          if (@val.length < 2) {
              return 0;
          }
          # подготовка
          # в зависимости от ориентации слайдера
          a = @orientation ?
              [coords.y - @elementOffset.top,  "height", "top", @elementSize.h, 0] :
              [coords.x - @elementOffset.left, "width", "left", @elementSize.w, 0];
          # для каждого ползунка
          for (b = 0; b < @val.length; b++)
          {
              # определяем его центр
              c = @handleOffset[b][a[2]] + @handleSize[b][a[1]] / 2.0;
              # определяем расстояние до центра
              if ((d = Math.abs(c - a[0])) < a[3])
              {
                  # найден ближайший ползунок
                  a[3] = d;
                  a[4] = b;
              }
              else if (Math.abs(d - a[3]) < 0.0001)
              {
                  # ползунки находятся в одной позиции,
                  # определяем положение относительно этой позиции
                  if (!@orientation && a[0] - c >= 0)
                  {
                      # выбираем ползунок справа
                      a[3] = d;
                      a[4] = b;
                  }
                  else if (@orientation && a[0] - c < 0)
                  {
                      # выбираем ползунок сверху
                      a[3] = d;
                      a[4] = b;
                  }
              }
          }
          return a[4];
      },
      # }}}
      _valueMin: function(index) { # {{{
          if (@val.length < 2 || !index) {
              return @min;
          }
          return @val[index - 1] + @options.margin;
      },
      # }}}
      _valueMax: function(index) { # {{{
          if (@val.length < 2 ||
              index === undefined ||
              index + 1 >= @val.length)
          {
              return @max;
          }
          return @val[index + 1] - @options.margin;
      },
      # }}}
  valRefine: (val, outside) -> # {{{
      # prepare
      d = @data
      o = @options
      # single value
      if typeof! val != "Array"
          # apply reversed
          val = d.max - val + d.min if d.reversed
          # apply shift
          val = val + d.shift if d.shift and outside
          # trim
          return @valTrim val
      # multiple values
      # sync length
      while val.length < d.val.length
          val.push @valRefine d.max, outside
      # fix
      if outside
          # value is from outside world
          # apply shift and reversed
          val = val + d.shift if d.shift and outside
          d.reversed and val = val.map (val) ->
              d.max - val + d.min;
      else
          # на вход
          val = val.map(function(val, index) {
              # только целые числа в ограниченном диапазоне
              val = @_valueTrim(val, index, true, true);
              # инвертируем значение
              return a ? (@max - val + @min) : val;
          }, this).sort(function(e1, e2) {
              # сортировка по возрастанию
              return e1 < e2 ? -1 : 1;
          });
          (a = @options.margin) && (val = val.map(function(val, index, arr) {
              # корректируем значение в соответствии с отступом
              # определяем диапазон
              b = jQuery.inArray(index, @_rangeMap);
              # отступ привязан к начальному ползунку диапазонa
              if (b >= 0 && !(b & 1) && (c = @_rangeMap[b + 1]) > 0 &&
                  arr[c] - a < val) # отступ нарушен
              {
                  # корректировка
                  # отталкиваемся от верхней границы
                  val = arr[c] - a;
                  if (val <= @min)
                  {
                      # на дне, поднимаем верхнюю границу
                      val = @min;
                      d = val + a;
                      arr[c] = d > @max ? @max : d;
                  }
              }
              return val;
          }, this));
      }
      return val;
      # ..
      true
  # }}}
  valTrim: (val, index, noMargin, forceStep) -> # {{{
      # returns the closest +step+margin-aligned value
      ##
      # подготовка
      forceStep = (forceStep && index !== undefined);
      # определим минимум и максимум
      a = [@min, @max, @min, @max];
      b = @val.length;
      c = 0;
      if (arguments.length > 1 && (b = @val.length) > 1)
      {
          # для нескольких ползунков,
          # границами являются соседние, но если задан флаг форсирования шага,
          # значение должно быть выравнено - упользуются границы min/max.
          if (!forceStep)
          {
              if (index > 0) {
                  a[0] = @val[index - 1];
              }
              if (index < b - 1) {
                  a[1] = @val[index + 1];
              }
          }
          # учитываем +margin
          if ((c = @options.margin) && (d = jQuery.inArray(index, @_rangeMap)) >= 0)
          {
              # в зависимости от четности/нечетности,
              # добавляем ограничение
              if (d & 1) {
                  a[2] = a[0] + c;
              }
              else {
                  a[3] = a[1] - c;
              }
          }
      }
      # проверка выхода за границы
      if (val < a[2]) {
          return a[2];
      }
      if (val > a[3]) {
          return a[3];
      }
      # корректируем значение
      if (@step)
      {
          # определим размер шага
          d = (@max - @min) / @step;
          d <= 1 && (d = 1);
          # приближаемся к значению
          for (b = @min; b + d <= val; b += d);
          b = [b, b + d];
          # определим ближайшее
          d = [Math.abs(val - b[0]), Math.abs(val - b[1])];
          if (d[0] !== d[1])
          {
              # найдено
              val = d[0] < d[1] ? b[0] : b[1];
          }
          else
          {
              # оба приближения равноудалены,
              # выбираем ближаешее к границе
              d = [b[0] - a[0], a[1] - b[1]];
              if (d[0] !== d[1])
              {
                  # найдено
                  val = d[0] < d[1] ? b[0] : b[1];
              }
              else if (forceStep)
              {
                  # по центру,
                  # определим ближайшее к текущему
                  return @val[index] <= b[0] ? b[0] : b[1];
              }
              else
              {
                  # по центру,
                  # возвращаем как есть
                  return val;
              }
          }
          # проверим выход за границы
          if (noMargin)
          {
              val > a[1] && (val = a[1]);
              val < a[0] && (val = a[0]);
          }
          else
          {
              val > a[3] && (val = a[3]);
              val < a[2] && (val = a[2]);
          }
      }
      return Math.round(val);
  },
  # }}}
  /** }}} **/
  /**** }}} */
});
w3ui && (w3ui.sensor = {
  /* {{{
  * TODO:
  */
  options: {
    empty: true
  },
  data: {
    target: [],
    sensor: [],
    event: [],
    state: null
  },
  create: function(){
    var me, d, i$, ref$, len$, b, a;
    me = this;
    d = this.data;
    this.refresh();
    this.scan().forEach(function(node){
      return me.add(node);
    });
    for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
      b = i$;
      a = ref$[i$];
      a[0].addEventListener("scroll", d.event[b]);
      a[2].addEventListener("scroll", d.event[b]);
      this.recharge(b);
    }
    return true;
  },
  destroy: function(){
    var d, i$, ref$, len$, b, a, c;
    d = this.data;
    for (i$ = 0, len$ = (ref$ = d.sensor).length; i$ < len$; ++i$) {
      b = i$;
      a = ref$[i$];
      a[0].removeEventListener("scroll", d.event[b]);
      a[2].removeEventListener("scroll", d.event[b]);
      c = a.data(d['class']);
      if (!c || c === 1) {
        a.remove();
      } else {
        a.data(d['class'], c - 1);
      }
    }
    d.target.length = 0;
    d.sensor.length = 0;
    d.event.length = 0;
  },
  attach: function(){
    return true;
  },
  detach: function(){
    return true;
  },
  event: function(handler, event){
    var a;
    if (this.options.disabled || this.core.options.disabled) {
      event.stopPropagation();
      event.preventDefault();
      return false;
    }
    if (a = this[handler](event)) {
      event.stopImmediatePropagation();
      event.stopPropagation();
      event.preventDefault();
    }
    return a;
  }
  /*
  refresh: !-> # {{{
      # prepare
      a = @element.0
      a =
          [a.offsetLeft, a.offsetTop]
          [a.offsetWidth, a.offsetHeight]
          [a.scrollLeft, a.scrollTop]
      # fix
      a.0.map (val) ->
          if val == null then 0 else val
      # store
      @data.state = a
  # }}}
  scan: -> # {{{
      # prepare
      me = @
      d  = @data
      # collect parents
      a = @element.parents!get!
      # add self
      a.push @element
      return a if a.length == 1
      # limit parents to document's body
      if (b = a.indexOf document.body) > 0
          a = a.slice 0, b - 1
      # prepare filter
      b =
          display:  [\block \flex]
          position: [\static \relative]
      # collect children of each parent container
      # take only those which may affect
      # size and offset (declared first)
      c = @element # first stop element
      for parent in a.slice!
          for node,index in parent.children
              # cancel at stop element
              break if node == c
              # check node
              # get styles in array
              d = $ node .css b.keys! .entries!
              # it must be a realative block container
              d = d.every (node) ->
                  b[node.0] and b[node.0].includes node.1
              # store
              a.push node if d
          # set next stop
          c = parent
      # result
      a
  # }}}
  add: (node) !-> # {{{
      # prepare
      me = @
      d  = @data
      # check if already added
      return if d.target.includes node
      # search sensor
      c = $ node
      if (a = c.children "." + d.class).length == 0
          # sensor not found
          # create DOM node
          a = document.createElement "div"
          a.className = d.class
          b = "position:absolute;left:0;top:0;"
          a.style.cssText = b +
              "right:0;bottom:0;" +
              "overflow:hidden;z-index:-1;visibility:hidden;opacity:0;"
          a.innerHTML =
              "<div style='" + a.style.cssText + "'><div style='" + b + "'></div></div>" +
              "<div style='" + b + "width:200%;height:200%;'></div>"
          # store in target container
          c.append a
          # switch container position to relative
          b = \position
          c.css b, \relative if c.css b == \static
          # define sensor nodes
          a = $ a
          b = a.0
          a.add [
              # shrink
              b.children.1
              # expand
              b.children.0
              b.children.0.children.0
          ]
      # sensor found
      # increment listener count
      b = 0 if not b = a.data d.class
      a.data d.class, b + 1
      # save
      b = d.sensor.length
      d.target[b] = node
      d.sensor[b] = a
      d.event[b]  = @event.bind @, b
      true
  # }}}
  event: (index, event) -> # target scroll {{{
      # prepare
      d = @data
      s = d.state
      # event handled
      event.stopPropagation!
      event.preventDefault!
      # update state
      @refresh!
      @recharge index
      # dont call api if disabled
      return true if @options.disabled
      # check for change
      a = s.map (lst, a) ->
          lst.some (val, b) ->
              (Math.abs val - s[a][b]) > 0.00001
      # no changes, quit
      return true if a.every (val) -> val == false
      # callback
      @api.offset.apply @core, a[0] if a[0]
      @api.resize.apply @core, a[1] if a[1]
      @api.scroll.apply @core, a[2] if a[2]
      true
  # }}}
  recharge: (index) !-> # {{{
      # prepare
      return if not a = @data.sensor[index]
      # reset
      b = 10000
      a[0].scrollLeft   = b
      a[0].scrollTop    = b
      a[2].scrollLeft   = b
      a[2].scrollTop    = b
      a[3].style.width  = b + "px"
      a[3].style.height = b + "px"
  # }}}
  */,
  api: {
    offset: function(x, y){},
    resize: function(x, y){},
    scroll: function(x, y){}
  }
  /**** }}} */
});
function clone$(it){
  function fun(){} fun.prototype = it;
  return new fun;
}
function import$(obj, src){
  var own = {}.hasOwnProperty;
  for (var key in src) if (own.call(src, key)) obj[key] = src[key];
  return obj;
}
function in$(x, xs){
  var i = -1, l = xs.length >>> 0;
  while (++i < l) if (x === xs[i]) return true;
  return false;
}